// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// AccountDnsBackResolveParams is parameters of accountDnsBackResolve operation.
type AccountDnsBackResolveParams struct {
	// Account ID.
	AccountID string
}

func unpackAccountDnsBackResolveParams(packed middleware.Parameters) (params AccountDnsBackResolveParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeAccountDnsBackResolveParams(args [1]string, argsEscaped bool, r *http.Request) (params AccountDnsBackResolveParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AddressParseParams is parameters of addressParse operation.
type AddressParseParams struct {
	// Account ID.
	AccountID string
}

func unpackAddressParseParams(packed middleware.Parameters) (params AddressParseParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeAddressParseParams(args [1]string, argsEscaped bool, r *http.Request) (params AddressParseParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// BlockchainAccountInspectParams is parameters of blockchainAccountInspect operation.
type BlockchainAccountInspectParams struct {
	// Account ID.
	AccountID string
}

func unpackBlockchainAccountInspectParams(packed middleware.Parameters) (params BlockchainAccountInspectParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeBlockchainAccountInspectParams(args [1]string, argsEscaped bool, r *http.Request) (params BlockchainAccountInspectParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DnsResolveParams is parameters of dnsResolve operation.
type DnsResolveParams struct {
	// Domain name with .ton or .t.me.
	DomainName string
}

func unpackDnsResolveParams(packed middleware.Parameters) (params DnsResolveParams) {
	{
		key := middleware.ParameterKey{
			Name: "domain_name",
			In:   "path",
		}
		params.DomainName = packed[key].(string)
	}
	return params
}

func decodeDnsResolveParams(args [1]string, argsEscaped bool, r *http.Request) (params DnsResolveParams, _ error) {
	// Decode path: domain_name.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domain_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domain_name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// EmulateMessageToAccountEventParams is parameters of emulateMessageToAccountEvent operation.
type EmulateMessageToAccountEventParams struct {
	AcceptLanguage OptString
	// Account ID.
	AccountID            string
	IgnoreSignatureCheck OptBool
}

func unpackEmulateMessageToAccountEventParams(packed middleware.Parameters) (params EmulateMessageToAccountEventParams) {
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "ignore_signature_check",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IgnoreSignatureCheck = v.(OptBool)
		}
	}
	return params
}

func decodeEmulateMessageToAccountEventParams(args [1]string, argsEscaped bool, r *http.Request) (params EmulateMessageToAccountEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: ignore_signature_check.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ignore_signature_check",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIgnoreSignatureCheckVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIgnoreSignatureCheckVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IgnoreSignatureCheck.SetTo(paramsDotIgnoreSignatureCheckVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ignore_signature_check",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// EmulateMessageToEventParams is parameters of emulateMessageToEvent operation.
type EmulateMessageToEventParams struct {
	AcceptLanguage       OptString
	IgnoreSignatureCheck OptBool
}

func unpackEmulateMessageToEventParams(packed middleware.Parameters) (params EmulateMessageToEventParams) {
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "ignore_signature_check",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IgnoreSignatureCheck = v.(OptBool)
		}
	}
	return params
}

func decodeEmulateMessageToEventParams(args [0]string, argsEscaped bool, r *http.Request) (params EmulateMessageToEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: ignore_signature_check.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ignore_signature_check",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIgnoreSignatureCheckVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIgnoreSignatureCheckVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IgnoreSignatureCheck.SetTo(paramsDotIgnoreSignatureCheckVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ignore_signature_check",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// EmulateMessageToTraceParams is parameters of emulateMessageToTrace operation.
type EmulateMessageToTraceParams struct {
	IgnoreSignatureCheck OptBool
}

func unpackEmulateMessageToTraceParams(packed middleware.Parameters) (params EmulateMessageToTraceParams) {
	{
		key := middleware.ParameterKey{
			Name: "ignore_signature_check",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IgnoreSignatureCheck = v.(OptBool)
		}
	}
	return params
}

func decodeEmulateMessageToTraceParams(args [0]string, argsEscaped bool, r *http.Request) (params EmulateMessageToTraceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: ignore_signature_check.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ignore_signature_check",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIgnoreSignatureCheckVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIgnoreSignatureCheckVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IgnoreSignatureCheck.SetTo(paramsDotIgnoreSignatureCheckVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ignore_signature_check",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// EmulateMessageToWalletParams is parameters of emulateMessageToWallet operation.
type EmulateMessageToWalletParams struct {
	AcceptLanguage OptString
}

func unpackEmulateMessageToWalletParams(packed middleware.Parameters) (params EmulateMessageToWalletParams) {
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeEmulateMessageToWalletParams(args [0]string, argsEscaped bool, r *http.Request) (params EmulateMessageToWalletParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}

// ExecGetMethodForBlockchainAccountParams is parameters of execGetMethodForBlockchainAccount operation.
type ExecGetMethodForBlockchainAccountParams struct {
	// Account ID.
	AccountID string
	// Contract get method name.
	MethodName string
	Args       []string
}

func unpackExecGetMethodForBlockchainAccountParams(packed middleware.Parameters) (params ExecGetMethodForBlockchainAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "method_name",
			In:   "path",
		}
		params.MethodName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "args",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Args = v.([]string)
		}
	}
	return params
}

func decodeExecGetMethodForBlockchainAccountParams(args [2]string, argsEscaped bool, r *http.Request) (params ExecGetMethodForBlockchainAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: method_name.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "method_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MethodName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "method_name",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: args.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "args",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotArgsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotArgsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Args = append(params.Args, paramsDotArgsVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "args",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GaslessEstimateParams is parameters of gaslessEstimate operation.
type GaslessEstimateParams struct {
	// Jetton to pay commission.
	MasterID string
}

func unpackGaslessEstimateParams(packed middleware.Parameters) (params GaslessEstimateParams) {
	{
		key := middleware.ParameterKey{
			Name: "master_id",
			In:   "path",
		}
		params.MasterID = packed[key].(string)
	}
	return params
}

func decodeGaslessEstimateParams(args [1]string, argsEscaped bool, r *http.Request) (params GaslessEstimateParams, _ error) {
	// Decode path: master_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "master_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MasterID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "master_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountParams is parameters of getAccount operation.
type GetAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetAccountParams(packed middleware.Parameters) (params GetAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetAccountParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountDiffParams is parameters of getAccountDiff operation.
type GetAccountDiffParams struct {
	// Account ID.
	AccountID string
	StartDate int64
	EndDate   int64
}

func unpackGetAccountDiffParams(packed middleware.Parameters) (params GetAccountDiffParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		params.StartDate = packed[key].(int64)
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		params.EndDate = packed[key].(int64)
	}
	return params
}

func decodeGetAccountDiffParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountDiffParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: start_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.StartDate = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_date",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.EndDate = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_date",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountDnsExpiringParams is parameters of getAccountDnsExpiring operation.
type GetAccountDnsExpiringParams struct {
	// Account ID.
	AccountID string
	// Number of days before expiration.
	Period OptInt
}

func unpackGetAccountDnsExpiringParams(packed middleware.Parameters) (params GetAccountDnsExpiringParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "period",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Period = v.(OptInt)
		}
	}
	return params
}

func decodeGetAccountDnsExpiringParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountDnsExpiringParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: period.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "period",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPeriodVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPeriodVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Period.SetTo(paramsDotPeriodVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Period.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           3660,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "period",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountEventParams is parameters of getAccountEvent operation.
type GetAccountEventParams struct {
	// Account ID.
	AccountID string
	// Event ID or transaction hash in hex (without 0x) or base64url format.
	EventID        string
	AcceptLanguage OptString
	// Filter actions where requested account is not real subject (for example sender or receiver jettons).
	SubjectOnly OptBool
}

func unpackGetAccountEventParams(packed middleware.Parameters) (params GetAccountEventParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "event_id",
			In:   "path",
		}
		params.EventID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "subject_only",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SubjectOnly = v.(OptBool)
		}
	}
	return params
}

func decodeGetAccountEventParams(args [2]string, argsEscaped bool, r *http.Request) (params GetAccountEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: event_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "event_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EventID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "event_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	// Set default value for query: subject_only.
	{
		val := bool(false)
		params.SubjectOnly.SetTo(val)
	}
	// Decode query: subject_only.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "subject_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSubjectOnlyVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSubjectOnlyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SubjectOnly.SetTo(paramsDotSubjectOnlyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "subject_only",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountEventsParams is parameters of getAccountEvents operation.
type GetAccountEventsParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
	// Show only events that are initiated by this account.
	Initiator OptBool
	// Filter actions where requested account is not real subject (for example sender or receiver jettons).
	SubjectOnly OptBool
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetAccountEventsParams(packed middleware.Parameters) (params GetAccountEventsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "initiator",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Initiator = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "subject_only",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SubjectOnly = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetAccountEventsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountEventsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	// Set default value for query: initiator.
	{
		val := bool(false)
		params.Initiator.SetTo(val)
	}
	// Decode query: initiator.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "initiator",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotInitiatorVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotInitiatorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Initiator.SetTo(paramsDotInitiatorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "initiator",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: subject_only.
	{
		val := bool(false)
		params.SubjectOnly.SetTo(val)
	}
	// Decode query: subject_only.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "subject_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSubjectOnlyVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSubjectOnlyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SubjectOnly.SetTo(paramsDotSubjectOnlyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "subject_only",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: before_lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before_lt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        true,
					Max:           100,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_date",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_date",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountInscriptionsParams is parameters of getAccountInscriptions operation.
type GetAccountInscriptionsParams struct {
	// Account ID.
	AccountID string
	Limit     OptInt
	Offset    OptInt
}

func unpackGetAccountInscriptionsParams(packed middleware.Parameters) (params GetAccountInscriptionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetAccountInscriptionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountInscriptionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(1000)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountInscriptionsHistoryParams is parameters of getAccountInscriptionsHistory operation.
type GetAccountInscriptionsHistoryParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
	// Omit this parameter to get last events.
	BeforeLt OptInt64
	Limit    OptInt
}

func unpackGetAccountInscriptionsHistoryParams(packed middleware.Parameters) (params GetAccountInscriptionsHistoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeGetAccountInscriptionsHistoryParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountInscriptionsHistoryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: before_lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before_lt",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountInscriptionsHistoryByTickerParams is parameters of getAccountInscriptionsHistoryByTicker operation.
type GetAccountInscriptionsHistoryByTickerParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
	Ticker         string
	// Omit this parameter to get last events.
	BeforeLt OptInt64
	Limit    OptInt
}

func unpackGetAccountInscriptionsHistoryByTickerParams(packed middleware.Parameters) (params GetAccountInscriptionsHistoryByTickerParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "ticker",
			In:   "path",
		}
		params.Ticker = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeGetAccountInscriptionsHistoryByTickerParams(args [2]string, argsEscaped bool, r *http.Request) (params GetAccountInscriptionsHistoryByTickerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	// Decode path: ticker.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ticker",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ticker = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ticker",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: before_lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before_lt",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountJettonBalanceParams is parameters of getAccountJettonBalance operation.
type GetAccountJettonBalanceParams struct {
	// Account ID.
	AccountID string
	// Jetton ID.
	JettonID string
	// Accept ton and all possible fiat currencies, separated by commas.
	Currencies []string
}

func unpackGetAccountJettonBalanceParams(packed middleware.Parameters) (params GetAccountJettonBalanceParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "jetton_id",
			In:   "path",
		}
		params.JettonID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "currencies",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Currencies = v.([]string)
		}
	}
	return params
}

func decodeGetAccountJettonBalanceParams(args [2]string, argsEscaped bool, r *http.Request) (params GetAccountJettonBalanceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: jetton_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jetton_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JettonID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jetton_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: currencies.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "currencies",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotCurrenciesVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotCurrenciesVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Currencies = append(params.Currencies, paramsDotCurrenciesVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "currencies",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountJettonHistoryByIDParams is parameters of getAccountJettonHistoryByID operation.
type GetAccountJettonHistoryByIDParams struct {
	// Account ID.
	AccountID string
	// Jetton ID.
	JettonID       string
	AcceptLanguage OptString
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetAccountJettonHistoryByIDParams(packed middleware.Parameters) (params GetAccountJettonHistoryByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "jetton_id",
			In:   "path",
		}
		params.JettonID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetAccountJettonHistoryByIDParams(args [2]string, argsEscaped bool, r *http.Request) (params GetAccountJettonHistoryByIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: jetton_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jetton_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JettonID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jetton_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: before_lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before_lt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        true,
					Max:           1000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_date",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_date",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountJettonsBalancesParams is parameters of getAccountJettonsBalances operation.
type GetAccountJettonsBalancesParams struct {
	// Account ID.
	AccountID string
	// Accept ton and all possible fiat currencies, separated by commas.
	Currencies []string
}

func unpackGetAccountJettonsBalancesParams(packed middleware.Parameters) (params GetAccountJettonsBalancesParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "currencies",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Currencies = v.([]string)
		}
	}
	return params
}

func decodeGetAccountJettonsBalancesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountJettonsBalancesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: currencies.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "currencies",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotCurrenciesVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotCurrenciesVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Currencies = append(params.Currencies, paramsDotCurrenciesVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "currencies",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountJettonsHistoryParams is parameters of getAccountJettonsHistory operation.
type GetAccountJettonsHistoryParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetAccountJettonsHistoryParams(packed middleware.Parameters) (params GetAccountJettonsHistoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetAccountJettonsHistoryParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountJettonsHistoryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: before_lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before_lt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        true,
					Max:           1000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_date",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_date",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountNftHistoryParams is parameters of getAccountNftHistory operation.
type GetAccountNftHistoryParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetAccountNftHistoryParams(packed middleware.Parameters) (params GetAccountNftHistoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetAccountNftHistoryParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountNftHistoryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: before_lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before_lt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        true,
					Max:           1000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_date",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_date",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountNftItemsParams is parameters of getAccountNftItems operation.
type GetAccountNftItemsParams struct {
	// Account ID.
	AccountID string
	// Nft collection.
	Collection OptString
	Limit      OptInt
	Offset     OptInt
	// Selling nft items in ton implemented usually via transfer items to special selling account. This
	// option enables including items which owned not directly.
	IndirectOwnership OptBool
}

func unpackGetAccountNftItemsParams(packed middleware.Parameters) (params GetAccountNftItemsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "collection",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Collection = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "indirect_ownership",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IndirectOwnership = v.(OptBool)
		}
	}
	return params
}

func decodeGetAccountNftItemsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountNftItemsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: collection.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "collection",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCollectionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCollectionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Collection.SetTo(paramsDotCollectionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "collection",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(1000)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: indirect_ownership.
	{
		val := bool(false)
		params.IndirectOwnership.SetTo(val)
	}
	// Decode query: indirect_ownership.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "indirect_ownership",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIndirectOwnershipVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIndirectOwnershipVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IndirectOwnership.SetTo(paramsDotIndirectOwnershipVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "indirect_ownership",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountNominatorsPoolsParams is parameters of getAccountNominatorsPools operation.
type GetAccountNominatorsPoolsParams struct {
	// Account ID.
	AccountID string
}

func unpackGetAccountNominatorsPoolsParams(packed middleware.Parameters) (params GetAccountNominatorsPoolsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetAccountNominatorsPoolsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountNominatorsPoolsParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountPublicKeyParams is parameters of getAccountPublicKey operation.
type GetAccountPublicKeyParams struct {
	// Account ID.
	AccountID string
}

func unpackGetAccountPublicKeyParams(packed middleware.Parameters) (params GetAccountPublicKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetAccountPublicKeyParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountPublicKeyParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountSeqnoParams is parameters of getAccountSeqno operation.
type GetAccountSeqnoParams struct {
	// Account ID.
	AccountID string
}

func unpackGetAccountSeqnoParams(packed middleware.Parameters) (params GetAccountSeqnoParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetAccountSeqnoParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountSeqnoParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountSubscriptionsParams is parameters of getAccountSubscriptions operation.
type GetAccountSubscriptionsParams struct {
	// Account ID.
	AccountID string
}

func unpackGetAccountSubscriptionsParams(packed middleware.Parameters) (params GetAccountSubscriptionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetAccountSubscriptionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountSubscriptionsParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAccountTracesParams is parameters of getAccountTraces operation.
type GetAccountTracesParams struct {
	// Account ID.
	AccountID string
	// Omit this parameter to get last events.
	BeforeLt OptInt64
	Limit    OptInt
}

func unpackGetAccountTracesParams(packed middleware.Parameters) (params GetAccountTracesParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeGetAccountTracesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAccountTracesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: before_lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before_lt",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAllAuctionsParams is parameters of getAllAuctions operation.
type GetAllAuctionsParams struct {
	// Domain filter for current auctions "ton" or "t.me".
	Tld OptString
}

func unpackGetAllAuctionsParams(packed middleware.Parameters) (params GetAllAuctionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "tld",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tld = v.(OptString)
		}
	}
	return params
}

func decodeGetAllAuctionsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetAllAuctionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: tld.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tld",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTldVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTldVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Tld.SetTo(paramsDotTldVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tld",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAllRawShardsInfoParams is parameters of getAllRawShardsInfo operation.
type GetAllRawShardsInfoParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
}

func unpackGetAllRawShardsInfoParams(packed middleware.Parameters) (params GetAllRawShardsInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetAllRawShardsInfoParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAllRawShardsInfoParams, _ error) {
	// Decode path: block_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "block_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBlockchainAccountTransactionsParams is parameters of getBlockchainAccountTransactions operation.
type GetBlockchainAccountTransactionsParams struct {
	// Account ID.
	AccountID string
	// Omit this parameter to get last transactions.
	AfterLt OptInt64
	// Omit this parameter to get last transactions.
	BeforeLt  OptInt64
	Limit     OptInt32
	SortOrder OptGetBlockchainAccountTransactionsSortOrder
}

func unpackGetBlockchainAccountTransactionsParams(packed middleware.Parameters) (params GetBlockchainAccountTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "after_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AfterLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort_order",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SortOrder = v.(OptGetBlockchainAccountTransactionsSortOrder)
		}
	}
	return params
}

func decodeGetBlockchainAccountTransactionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBlockchainAccountTransactionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: after_lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotAfterLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AfterLt.SetTo(paramsDotAfterLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "after_lt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: before_lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before_lt",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: sort_order.
	{
		val := GetBlockchainAccountTransactionsSortOrder("desc")
		params.SortOrder.SetTo(val)
	}
	// Decode query: sort_order.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort_order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortOrderVal GetBlockchainAccountTransactionsSortOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortOrderVal = GetBlockchainAccountTransactionsSortOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.SortOrder.SetTo(paramsDotSortOrderVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.SortOrder.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort_order",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetBlockchainBlockParams is parameters of getBlockchainBlock operation.
type GetBlockchainBlockParams struct {
	// Block ID.
	BlockID string
}

func unpackGetBlockchainBlockParams(packed middleware.Parameters) (params GetBlockchainBlockParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetBlockchainBlockParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBlockchainBlockParams, _ error) {
	// Decode path: block_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "block_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBlockchainBlockTransactionsParams is parameters of getBlockchainBlockTransactions operation.
type GetBlockchainBlockTransactionsParams struct {
	// Block ID.
	BlockID string
}

func unpackGetBlockchainBlockTransactionsParams(packed middleware.Parameters) (params GetBlockchainBlockTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetBlockchainBlockTransactionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBlockchainBlockTransactionsParams, _ error) {
	// Decode path: block_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "block_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBlockchainConfigFromBlockParams is parameters of getBlockchainConfigFromBlock operation.
type GetBlockchainConfigFromBlockParams struct {
	// Masterchain block seqno.
	MasterchainSeqno int32
}

func unpackGetBlockchainConfigFromBlockParams(packed middleware.Parameters) (params GetBlockchainConfigFromBlockParams) {
	{
		key := middleware.ParameterKey{
			Name: "masterchain_seqno",
			In:   "path",
		}
		params.MasterchainSeqno = packed[key].(int32)
	}
	return params
}

func decodeGetBlockchainConfigFromBlockParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBlockchainConfigFromBlockParams, _ error) {
	// Decode path: masterchain_seqno.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "masterchain_seqno",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.MasterchainSeqno = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "masterchain_seqno",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBlockchainMasterchainBlocksParams is parameters of getBlockchainMasterchainBlocks operation.
type GetBlockchainMasterchainBlocksParams struct {
	// Masterchain block seqno.
	MasterchainSeqno int32
}

func unpackGetBlockchainMasterchainBlocksParams(packed middleware.Parameters) (params GetBlockchainMasterchainBlocksParams) {
	{
		key := middleware.ParameterKey{
			Name: "masterchain_seqno",
			In:   "path",
		}
		params.MasterchainSeqno = packed[key].(int32)
	}
	return params
}

func decodeGetBlockchainMasterchainBlocksParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBlockchainMasterchainBlocksParams, _ error) {
	// Decode path: masterchain_seqno.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "masterchain_seqno",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.MasterchainSeqno = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "masterchain_seqno",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBlockchainMasterchainShardsParams is parameters of getBlockchainMasterchainShards operation.
type GetBlockchainMasterchainShardsParams struct {
	// Masterchain block seqno.
	MasterchainSeqno int32
}

func unpackGetBlockchainMasterchainShardsParams(packed middleware.Parameters) (params GetBlockchainMasterchainShardsParams) {
	{
		key := middleware.ParameterKey{
			Name: "masterchain_seqno",
			In:   "path",
		}
		params.MasterchainSeqno = packed[key].(int32)
	}
	return params
}

func decodeGetBlockchainMasterchainShardsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBlockchainMasterchainShardsParams, _ error) {
	// Decode path: masterchain_seqno.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "masterchain_seqno",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.MasterchainSeqno = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "masterchain_seqno",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBlockchainMasterchainTransactionsParams is parameters of getBlockchainMasterchainTransactions operation.
type GetBlockchainMasterchainTransactionsParams struct {
	// Masterchain block seqno.
	MasterchainSeqno int32
}

func unpackGetBlockchainMasterchainTransactionsParams(packed middleware.Parameters) (params GetBlockchainMasterchainTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "masterchain_seqno",
			In:   "path",
		}
		params.MasterchainSeqno = packed[key].(int32)
	}
	return params
}

func decodeGetBlockchainMasterchainTransactionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBlockchainMasterchainTransactionsParams, _ error) {
	// Decode path: masterchain_seqno.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "masterchain_seqno",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.MasterchainSeqno = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "masterchain_seqno",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBlockchainRawAccountParams is parameters of getBlockchainRawAccount operation.
type GetBlockchainRawAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetBlockchainRawAccountParams(packed middleware.Parameters) (params GetBlockchainRawAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetBlockchainRawAccountParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBlockchainRawAccountParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBlockchainTransactionParams is parameters of getBlockchainTransaction operation.
type GetBlockchainTransactionParams struct {
	// Transaction ID.
	TransactionID string
}

func unpackGetBlockchainTransactionParams(packed middleware.Parameters) (params GetBlockchainTransactionParams) {
	{
		key := middleware.ParameterKey{
			Name: "transaction_id",
			In:   "path",
		}
		params.TransactionID = packed[key].(string)
	}
	return params
}

func decodeGetBlockchainTransactionParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBlockchainTransactionParams, _ error) {
	// Decode path: transaction_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "transaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TransactionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "transaction_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBlockchainTransactionByMessageHashParams is parameters of getBlockchainTransactionByMessageHash operation.
type GetBlockchainTransactionByMessageHashParams struct {
	// Message ID.
	MsgID string
}

func unpackGetBlockchainTransactionByMessageHashParams(packed middleware.Parameters) (params GetBlockchainTransactionByMessageHashParams) {
	{
		key := middleware.ParameterKey{
			Name: "msg_id",
			In:   "path",
		}
		params.MsgID = packed[key].(string)
	}
	return params
}

func decodeGetBlockchainTransactionByMessageHashParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBlockchainTransactionByMessageHashParams, _ error) {
	// Decode path: msg_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "msg_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MsgID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "msg_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetChartRatesParams is parameters of getChartRates operation.
type GetChartRatesParams struct {
	// Accept jetton master address.
	Token       string
	Currency    OptString
	StartDate   OptInt64
	EndDate     OptInt64
	PointsCount OptInt
}

func unpackGetChartRatesParams(packed middleware.Parameters) (params GetChartRatesParams) {
	{
		key := middleware.ParameterKey{
			Name: "token",
			In:   "query",
		}
		params.Token = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "currency",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Currency = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "points_count",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PointsCount = v.(OptInt)
		}
	}
	return params
}

func decodeGetChartRatesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetChartRatesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: token.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Token = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "token",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: currency.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "currency",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCurrencyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCurrencyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Currency.SetTo(paramsDotCurrencyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "currency",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_date",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_date",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: points_count.
	{
		val := int(200)
		params.PointsCount.SetTo(val)
	}
	// Decode query: points_count.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "points_count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPointsCountVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPointsCountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PointsCount.SetTo(paramsDotPointsCountVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.PointsCount.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        true,
							Max:           200,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "points_count",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetDnsInfoParams is parameters of getDnsInfo operation.
type GetDnsInfoParams struct {
	// Domain name with .ton or .t.me.
	DomainName string
}

func unpackGetDnsInfoParams(packed middleware.Parameters) (params GetDnsInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "domain_name",
			In:   "path",
		}
		params.DomainName = packed[key].(string)
	}
	return params
}

func decodeGetDnsInfoParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDnsInfoParams, _ error) {
	// Decode path: domain_name.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domain_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domain_name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDomainBidsParams is parameters of getDomainBids operation.
type GetDomainBidsParams struct {
	// Domain name with .ton or .t.me.
	DomainName string
}

func unpackGetDomainBidsParams(packed middleware.Parameters) (params GetDomainBidsParams) {
	{
		key := middleware.ParameterKey{
			Name: "domain_name",
			In:   "path",
		}
		params.DomainName = packed[key].(string)
	}
	return params
}

func decodeGetDomainBidsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDomainBidsParams, _ error) {
	// Decode path: domain_name.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domain_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domain_name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetEventParams is parameters of getEvent operation.
type GetEventParams struct {
	// Event ID or transaction hash in hex (without 0x) or base64url format.
	EventID        string
	AcceptLanguage OptString
}

func unpackGetEventParams(packed middleware.Parameters) (params GetEventParams) {
	{
		key := middleware.ParameterKey{
			Name: "event_id",
			In:   "path",
		}
		params.EventID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeGetEventParams(args [1]string, argsEscaped bool, r *http.Request) (params GetEventParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: event_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "event_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EventID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "event_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}

// GetInscriptionOpTemplateParams is parameters of getInscriptionOpTemplate operation.
type GetInscriptionOpTemplateParams struct {
	Type        GetInscriptionOpTemplateType
	Destination OptString
	Comment     OptString
	Operation   GetInscriptionOpTemplateOperation
	Amount      string
	Ticker      string
	Who         string
}

func unpackGetInscriptionOpTemplateParams(packed middleware.Parameters) (params GetInscriptionOpTemplateParams) {
	{
		key := middleware.ParameterKey{
			Name: "type",
			In:   "query",
		}
		params.Type = packed[key].(GetInscriptionOpTemplateType)
	}
	{
		key := middleware.ParameterKey{
			Name: "destination",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Destination = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "comment",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Comment = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "operation",
			In:   "query",
		}
		params.Operation = packed[key].(GetInscriptionOpTemplateOperation)
	}
	{
		key := middleware.ParameterKey{
			Name: "amount",
			In:   "query",
		}
		params.Amount = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "ticker",
			In:   "query",
		}
		params.Ticker = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "who",
			In:   "query",
		}
		params.Who = packed[key].(string)
	}
	return params
}

func decodeGetInscriptionOpTemplateParams(args [0]string, argsEscaped bool, r *http.Request) (params GetInscriptionOpTemplateParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Type = GetInscriptionOpTemplateType(c)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := params.Type.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "type",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: destination.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "destination",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDestinationVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDestinationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Destination.SetTo(paramsDotDestinationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "destination",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: comment.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "comment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCommentVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCommentVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Comment.SetTo(paramsDotCommentVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "comment",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: operation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "operation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Operation = GetInscriptionOpTemplateOperation(c)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := params.Operation.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "operation",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: amount.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "amount",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Amount = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "amount",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: ticker.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ticker",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ticker = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ticker",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: who.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "who",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Who = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "who",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetItemsFromCollectionParams is parameters of getItemsFromCollection operation.
type GetItemsFromCollectionParams struct {
	// Account ID.
	AccountID string
	Limit     OptInt
	Offset    OptInt
}

func unpackGetItemsFromCollectionParams(packed middleware.Parameters) (params GetItemsFromCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetItemsFromCollectionParams(args [1]string, argsEscaped bool, r *http.Request) (params GetItemsFromCollectionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(1000)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetJettonHoldersParams is parameters of getJettonHolders operation.
type GetJettonHoldersParams struct {
	// Account ID.
	AccountID string
	Limit     OptInt
	Offset    OptInt
}

func unpackGetJettonHoldersParams(packed middleware.Parameters) (params GetJettonHoldersParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetJettonHoldersParams(args [1]string, argsEscaped bool, r *http.Request) (params GetJettonHoldersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(1000)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetJettonInfoParams is parameters of getJettonInfo operation.
type GetJettonInfoParams struct {
	// Account ID.
	AccountID string
}

func unpackGetJettonInfoParams(packed middleware.Parameters) (params GetJettonInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetJettonInfoParams(args [1]string, argsEscaped bool, r *http.Request) (params GetJettonInfoParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetJettonsParams is parameters of getJettons operation.
type GetJettonsParams struct {
	Limit  OptInt32
	Offset OptInt32
}

func unpackGetJettonsParams(packed middleware.Parameters) (params GetJettonsParams) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	return params
}

func decodeGetJettonsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetJettonsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetJettonsEventsParams is parameters of getJettonsEvents operation.
type GetJettonsEventsParams struct {
	// Event ID or transaction hash in hex (without 0x) or base64url format.
	EventID        string
	AcceptLanguage OptString
}

func unpackGetJettonsEventsParams(packed middleware.Parameters) (params GetJettonsEventsParams) {
	{
		key := middleware.ParameterKey{
			Name: "event_id",
			In:   "path",
		}
		params.EventID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeGetJettonsEventsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetJettonsEventsParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: event_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "event_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EventID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "event_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}

// GetNftCollectionParams is parameters of getNftCollection operation.
type GetNftCollectionParams struct {
	// Account ID.
	AccountID string
}

func unpackGetNftCollectionParams(packed middleware.Parameters) (params GetNftCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetNftCollectionParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNftCollectionParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNftCollectionsParams is parameters of getNftCollections operation.
type GetNftCollectionsParams struct {
	Limit  OptInt32
	Offset OptInt32
}

func unpackGetNftCollectionsParams(packed middleware.Parameters) (params GetNftCollectionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	return params
}

func decodeGetNftCollectionsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetNftCollectionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetNftHistoryByIDParams is parameters of getNftHistoryByID operation.
type GetNftHistoryByIDParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetNftHistoryByIDParams(packed middleware.Parameters) (params GetNftHistoryByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetNftHistoryByIDParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNftHistoryByIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: before_lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before_lt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        true,
					Max:           1000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_date",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_date.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_date",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetNftItemByAddressParams is parameters of getNftItemByAddress operation.
type GetNftItemByAddressParams struct {
	// Account ID.
	AccountID string
}

func unpackGetNftItemByAddressParams(packed middleware.Parameters) (params GetNftItemByAddressParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetNftItemByAddressParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNftItemByAddressParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetRatesParams is parameters of getRates operation.
type GetRatesParams struct {
	// Accept ton and jetton master addresses, separated by commas.
	Tokens []string
	// Accept ton and all possible fiat currencies, separated by commas.
	Currencies []string
}

func unpackGetRatesParams(packed middleware.Parameters) (params GetRatesParams) {
	{
		key := middleware.ParameterKey{
			Name: "tokens",
			In:   "query",
		}
		params.Tokens = packed[key].([]string)
	}
	{
		key := middleware.ParameterKey{
			Name: "currencies",
			In:   "query",
		}
		params.Currencies = packed[key].([]string)
	}
	return params
}

func decodeGetRatesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetRatesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: tokens.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tokens",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotTokensVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotTokensVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Tokens = append(params.Tokens, paramsDotTokensVal)
					return nil
				})
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.Tokens == nil {
					return errors.New("nil is invalid value")
				}
				if err := (validate.Array{
					MinLength:    0,
					MinLengthSet: false,
					MaxLength:    100,
					MaxLengthSet: true,
				}).ValidateLength(len(params.Tokens)); err != nil {
					return errors.Wrap(err, "array")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokens",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: currencies.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "currencies",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotCurrenciesVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotCurrenciesVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Currencies = append(params.Currencies, paramsDotCurrenciesVal)
					return nil
				})
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.Currencies == nil {
					return errors.New("nil is invalid value")
				}
				if err := (validate.Array{
					MinLength:    0,
					MinLengthSet: false,
					MaxLength:    50,
					MaxLengthSet: true,
				}).ValidateLength(len(params.Currencies)); err != nil {
					return errors.Wrap(err, "array")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "currencies",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawAccountStateParams is parameters of getRawAccountState operation.
type GetRawAccountStateParams struct {
	// Account ID.
	AccountID string
	// Target block: (workchain,shard,seqno,root_hash,file_hash).
	TargetBlock OptString
}

func unpackGetRawAccountStateParams(packed middleware.Parameters) (params GetRawAccountStateParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "target_block",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TargetBlock = v.(OptString)
		}
	}
	return params
}

func decodeGetRawAccountStateParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRawAccountStateParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: target_block.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "target_block",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTargetBlockVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTargetBlockVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TargetBlock.SetTo(paramsDotTargetBlockVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "target_block",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawBlockProofParams is parameters of getRawBlockProof operation.
type GetRawBlockProofParams struct {
	// Known block: (workchain,shard,seqno,root_hash,file_hash).
	KnownBlock string
	// Target block: (workchain,shard,seqno,root_hash,file_hash).
	TargetBlock OptString
	// Mode.
	Mode int32
}

func unpackGetRawBlockProofParams(packed middleware.Parameters) (params GetRawBlockProofParams) {
	{
		key := middleware.ParameterKey{
			Name: "known_block",
			In:   "query",
		}
		params.KnownBlock = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "target_block",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TargetBlock = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "mode",
			In:   "query",
		}
		params.Mode = packed[key].(int32)
	}
	return params
}

func decodeGetRawBlockProofParams(args [0]string, argsEscaped bool, r *http.Request) (params GetRawBlockProofParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: known_block.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "known_block",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.KnownBlock = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "known_block",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: target_block.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "target_block",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTargetBlockVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTargetBlockVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TargetBlock.SetTo(paramsDotTargetBlockVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "target_block",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: mode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.Mode = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mode",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawBlockchainBlockParams is parameters of getRawBlockchainBlock operation.
type GetRawBlockchainBlockParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
}

func unpackGetRawBlockchainBlockParams(packed middleware.Parameters) (params GetRawBlockchainBlockParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetRawBlockchainBlockParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRawBlockchainBlockParams, _ error) {
	// Decode path: block_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "block_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawBlockchainBlockHeaderParams is parameters of getRawBlockchainBlockHeader operation.
type GetRawBlockchainBlockHeaderParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
	// Mode.
	Mode int32
}

func unpackGetRawBlockchainBlockHeaderParams(packed middleware.Parameters) (params GetRawBlockchainBlockHeaderParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mode",
			In:   "query",
		}
		params.Mode = packed[key].(int32)
	}
	return params
}

func decodeGetRawBlockchainBlockHeaderParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRawBlockchainBlockHeaderParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: block_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "block_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: mode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.Mode = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mode",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawBlockchainBlockStateParams is parameters of getRawBlockchainBlockState operation.
type GetRawBlockchainBlockStateParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
}

func unpackGetRawBlockchainBlockStateParams(packed middleware.Parameters) (params GetRawBlockchainBlockStateParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetRawBlockchainBlockStateParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRawBlockchainBlockStateParams, _ error) {
	// Decode path: block_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "block_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawBlockchainConfigFromBlockParams is parameters of getRawBlockchainConfigFromBlock operation.
type GetRawBlockchainConfigFromBlockParams struct {
	// Masterchain block seqno.
	MasterchainSeqno int32
}

func unpackGetRawBlockchainConfigFromBlockParams(packed middleware.Parameters) (params GetRawBlockchainConfigFromBlockParams) {
	{
		key := middleware.ParameterKey{
			Name: "masterchain_seqno",
			In:   "path",
		}
		params.MasterchainSeqno = packed[key].(int32)
	}
	return params
}

func decodeGetRawBlockchainConfigFromBlockParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRawBlockchainConfigFromBlockParams, _ error) {
	// Decode path: masterchain_seqno.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "masterchain_seqno",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.MasterchainSeqno = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "masterchain_seqno",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawConfigParams is parameters of getRawConfig operation.
type GetRawConfigParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
	// Mode.
	Mode int32
}

func unpackGetRawConfigParams(packed middleware.Parameters) (params GetRawConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mode",
			In:   "query",
		}
		params.Mode = packed[key].(int32)
	}
	return params
}

func decodeGetRawConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRawConfigParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: block_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "block_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: mode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.Mode = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mode",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawListBlockTransactionsParams is parameters of getRawListBlockTransactions operation.
type GetRawListBlockTransactionsParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
	// Mode.
	Mode int32
	// Count.
	Count int32
	// Account ID.
	AccountID OptString
	// Lt.
	Lt OptInt64
}

func unpackGetRawListBlockTransactionsParams(packed middleware.Parameters) (params GetRawListBlockTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mode",
			In:   "query",
		}
		params.Mode = packed[key].(int32)
	}
	{
		key := middleware.ParameterKey{
			Name: "count",
			In:   "query",
		}
		params.Count = packed[key].(int32)
	}
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AccountID = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Lt = v.(OptInt64)
		}
	}
	return params
}

func decodeGetRawListBlockTransactionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRawListBlockTransactionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: block_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "block_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: mode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.Mode = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mode",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: count.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.Count = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "count",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: account_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "account_id",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAccountIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAccountIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AccountID.SetTo(paramsDotAccountIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Lt.SetTo(paramsDotLtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "lt",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawMasterchainInfoExtParams is parameters of getRawMasterchainInfoExt operation.
type GetRawMasterchainInfoExtParams struct {
	// Mode.
	Mode int32
}

func unpackGetRawMasterchainInfoExtParams(packed middleware.Parameters) (params GetRawMasterchainInfoExtParams) {
	{
		key := middleware.ParameterKey{
			Name: "mode",
			In:   "query",
		}
		params.Mode = packed[key].(int32)
	}
	return params
}

func decodeGetRawMasterchainInfoExtParams(args [0]string, argsEscaped bool, r *http.Request) (params GetRawMasterchainInfoExtParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: mode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.Mode = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mode",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawShardBlockProofParams is parameters of getRawShardBlockProof operation.
type GetRawShardBlockProofParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
}

func unpackGetRawShardBlockProofParams(packed middleware.Parameters) (params GetRawShardBlockProofParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetRawShardBlockProofParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRawShardBlockProofParams, _ error) {
	// Decode path: block_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "block_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawShardInfoParams is parameters of getRawShardInfo operation.
type GetRawShardInfoParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
	// Workchain.
	Workchain int32
	// Shard.
	Shard int64
	// Exact.
	Exact bool
}

func unpackGetRawShardInfoParams(packed middleware.Parameters) (params GetRawShardInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "workchain",
			In:   "query",
		}
		params.Workchain = packed[key].(int32)
	}
	{
		key := middleware.ParameterKey{
			Name: "shard",
			In:   "query",
		}
		params.Shard = packed[key].(int64)
	}
	{
		key := middleware.ParameterKey{
			Name: "exact",
			In:   "query",
		}
		params.Exact = packed[key].(bool)
	}
	return params
}

func decodeGetRawShardInfoParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRawShardInfoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: block_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "block_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: workchain.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "workchain",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.Workchain = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "workchain",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: shard.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "shard",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.Shard = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "shard",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: exact.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exact",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToBool(val)
				if err != nil {
					return err
				}

				params.Exact = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "exact",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRawTransactionsParams is parameters of getRawTransactions operation.
type GetRawTransactionsParams struct {
	// Account ID.
	AccountID string
	// Count.
	Count int32
	// Lt.
	Lt int64
	// Hash.
	Hash string
}

func unpackGetRawTransactionsParams(packed middleware.Parameters) (params GetRawTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "count",
			In:   "query",
		}
		params.Count = packed[key].(int32)
	}
	{
		key := middleware.ParameterKey{
			Name: "lt",
			In:   "query",
		}
		params.Lt = packed[key].(int64)
	}
	{
		key := middleware.ParameterKey{
			Name: "hash",
			In:   "query",
		}
		params.Hash = packed[key].(string)
	}
	return params
}

func decodeGetRawTransactionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRawTransactionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: count.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.Count = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "count",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: lt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.Lt = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "lt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: hash.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "hash",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Hash = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "hash",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetStakingPoolHistoryParams is parameters of getStakingPoolHistory operation.
type GetStakingPoolHistoryParams struct {
	// Account ID.
	AccountID string
}

func unpackGetStakingPoolHistoryParams(packed middleware.Parameters) (params GetStakingPoolHistoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetStakingPoolHistoryParams(args [1]string, argsEscaped bool, r *http.Request) (params GetStakingPoolHistoryParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetStakingPoolInfoParams is parameters of getStakingPoolInfo operation.
type GetStakingPoolInfoParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
}

func unpackGetStakingPoolInfoParams(packed middleware.Parameters) (params GetStakingPoolInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeGetStakingPoolInfoParams(args [1]string, argsEscaped bool, r *http.Request) (params GetStakingPoolInfoParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}

// GetStakingPoolsParams is parameters of getStakingPools operation.
type GetStakingPoolsParams struct {
	// Account ID.
	AvailableFor OptString
	// Return also pools not from white list - just compatible by interfaces (maybe dangerous!).
	IncludeUnverified OptBool
	AcceptLanguage    OptString
}

func unpackGetStakingPoolsParams(packed middleware.Parameters) (params GetStakingPoolsParams) {
	{
		key := middleware.ParameterKey{
			Name: "available_for",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AvailableFor = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "include_unverified",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludeUnverified = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeGetStakingPoolsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetStakingPoolsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode query: available_for.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "available_for",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAvailableForVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAvailableForVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AvailableFor.SetTo(paramsDotAvailableForVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "available_for",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: include_unverified.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include_unverified",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeUnverifiedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIncludeUnverifiedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IncludeUnverified.SetTo(paramsDotIncludeUnverifiedVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "include_unverified",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Language",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}

// GetTraceParams is parameters of getTrace operation.
type GetTraceParams struct {
	// Trace ID or transaction hash in hex (without 0x) or base64url format.
	TraceID string
}

func unpackGetTraceParams(packed middleware.Parameters) (params GetTraceParams) {
	{
		key := middleware.ParameterKey{
			Name: "trace_id",
			In:   "path",
		}
		params.TraceID = packed[key].(string)
	}
	return params
}

func decodeGetTraceParams(args [1]string, argsEscaped bool, r *http.Request) (params GetTraceParams, _ error) {
	// Decode path: trace_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "trace_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TraceID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "trace_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetWalletBackupParams is parameters of getWalletBackup operation.
type GetWalletBackupParams struct {
	XTonConnectAuth string
}

func unpackGetWalletBackupParams(packed middleware.Parameters) (params GetWalletBackupParams) {
	{
		key := middleware.ParameterKey{
			Name: "X-TonConnect-Auth",
			In:   "header",
		}
		params.XTonConnectAuth = packed[key].(string)
	}
	return params
}

func decodeGetWalletBackupParams(args [0]string, argsEscaped bool, r *http.Request) (params GetWalletBackupParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: X-TonConnect-Auth.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "X-TonConnect-Auth",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.XTonConnectAuth = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "X-TonConnect-Auth",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}

// GetWalletsByPublicKeyParams is parameters of getWalletsByPublicKey operation.
type GetWalletsByPublicKeyParams struct {
	PublicKey string
}

func unpackGetWalletsByPublicKeyParams(packed middleware.Parameters) (params GetWalletsByPublicKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "public_key",
			In:   "path",
		}
		params.PublicKey = packed[key].(string)
	}
	return params
}

func decodeGetWalletsByPublicKeyParams(args [1]string, argsEscaped bool, r *http.Request) (params GetWalletsByPublicKeyParams, _ error) {
	// Decode path: public_key.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "public_key",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PublicKey = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "public_key",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReindexAccountParams is parameters of reindexAccount operation.
type ReindexAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackReindexAccountParams(packed middleware.Parameters) (params ReindexAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeReindexAccountParams(args [1]string, argsEscaped bool, r *http.Request) (params ReindexAccountParams, _ error) {
	// Decode path: account_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "account_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SearchAccountsParams is parameters of searchAccounts operation.
type SearchAccountsParams struct {
	Name string
}

func unpackSearchAccountsParams(packed middleware.Parameters) (params SearchAccountsParams) {
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeSearchAccountsParams(args [0]string, argsEscaped bool, r *http.Request) (params SearchAccountsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    3,
					MinLengthSet: true,
					MaxLength:    15,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Name)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// SetWalletBackupParams is parameters of setWalletBackup operation.
type SetWalletBackupParams struct {
	XTonConnectAuth string
}

func unpackSetWalletBackupParams(packed middleware.Parameters) (params SetWalletBackupParams) {
	{
		key := middleware.ParameterKey{
			Name: "X-TonConnect-Auth",
			In:   "header",
		}
		params.XTonConnectAuth = packed[key].(string)
	}
	return params
}

func decodeSetWalletBackupParams(args [0]string, argsEscaped bool, r *http.Request) (params SetWalletBackupParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: X-TonConnect-Auth.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "X-TonConnect-Auth",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.XTonConnectAuth = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "X-TonConnect-Auth",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}
