// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"net/http"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// DnsBackResolveParams is parameters of dnsBackResolve operation.
type DnsBackResolveParams struct {
	// Account ID.
	AccountID string
}

func unpackDnsBackResolveParams(packed middleware.Parameters) (params DnsBackResolveParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeDnsBackResolveParams(args [1]string, r *http.Request) (params DnsBackResolveParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// DnsInfoParams is parameters of dnsInfo operation.
type DnsInfoParams struct {
	// Domain name with .ton or .t.me.
	DomainName string
}

func unpackDnsInfoParams(packed middleware.Parameters) (params DnsInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "domain_name",
			In:   "path",
		}
		params.DomainName = packed[key].(string)
	}
	return params
}

func decodeDnsInfoParams(args [1]string, r *http.Request) (params DnsInfoParams, _ error) {
	// Decode path: domain_name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domain_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: domain_name: parse")
			}
		} else {
			return params, errors.New("path: domain_name: not specified")
		}
	}
	return params, nil
}

// DnsResolveParams is parameters of dnsResolve operation.
type DnsResolveParams struct {
	// Domain name with .ton or .t.me.
	DomainName string
}

func unpackDnsResolveParams(packed middleware.Parameters) (params DnsResolveParams) {
	{
		key := middleware.ParameterKey{
			Name: "domain_name",
			In:   "path",
		}
		params.DomainName = packed[key].(string)
	}
	return params
}

func decodeDnsResolveParams(args [1]string, r *http.Request) (params DnsResolveParams, _ error) {
	// Decode path: domain_name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domain_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: domain_name: parse")
			}
		} else {
			return params, errors.New("path: domain_name: not specified")
		}
	}
	return params, nil
}

// EmulateMessageToAccountEventParams is parameters of emulateMessageToAccountEvent operation.
type EmulateMessageToAccountEventParams struct {
	AcceptLanguage OptString
	// Account ID.
	AccountID string
}

func unpackEmulateMessageToAccountEventParams(packed middleware.Parameters) (params EmulateMessageToAccountEventParams) {
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeEmulateMessageToAccountEventParams(args [1]string, r *http.Request) (params EmulateMessageToAccountEventParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// EmulateMessageToEventParams is parameters of emulateMessageToEvent operation.
type EmulateMessageToEventParams struct {
	AcceptLanguage OptString
}

func unpackEmulateMessageToEventParams(packed middleware.Parameters) (params EmulateMessageToEventParams) {
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeEmulateMessageToEventParams(args [0]string, r *http.Request) (params EmulateMessageToEventParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	return params, nil
}

// EmulateWalletMessageParams is parameters of emulateWalletMessage operation.
type EmulateWalletMessageParams struct {
	AcceptLanguage OptString
}

func unpackEmulateWalletMessageParams(packed middleware.Parameters) (params EmulateWalletMessageParams) {
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeEmulateWalletMessageParams(args [0]string, r *http.Request) (params EmulateWalletMessageParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	return params, nil
}

// ExecGetMethodParams is parameters of execGetMethod operation.
type ExecGetMethodParams struct {
	// Account ID.
	AccountID string
	// Contract get method name.
	MethodName string
	Args       []string
}

func unpackExecGetMethodParams(packed middleware.Parameters) (params ExecGetMethodParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "method_name",
			In:   "path",
		}
		params.MethodName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "args",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Args = v.([]string)
		}
	}
	return params
}

func decodeExecGetMethodParams(args [2]string, r *http.Request) (params ExecGetMethodParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode path: method_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "method_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MethodName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: method_name: parse")
			}
		} else {
			return params, errors.New("path: method_name: not specified")
		}
	}
	// Decode query: args.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "args",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotArgsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotArgsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Args = append(params.Args, paramsDotArgsVal)
					return nil
				})
			}); err != nil {
				return params, errors.Wrap(err, "query: args: parse")
			}
		}
	}
	return params, nil
}

// GetAccountParams is parameters of getAccount operation.
type GetAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetAccountParams(packed middleware.Parameters) (params GetAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetAccountParams(args [1]string, r *http.Request) (params GetAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetAccountSeqnoParams is parameters of getAccountSeqno operation.
type GetAccountSeqnoParams struct {
	// Account ID.
	AccountID string
}

func unpackGetAccountSeqnoParams(packed middleware.Parameters) (params GetAccountSeqnoParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetAccountSeqnoParams(args [1]string, r *http.Request) (params GetAccountSeqnoParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetAccountStateLiteServerParams is parameters of getAccountStateLiteServer operation.
type GetAccountStateLiteServerParams struct {
	// Account ID.
	AccountID string
}

func unpackGetAccountStateLiteServerParams(packed middleware.Parameters) (params GetAccountStateLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetAccountStateLiteServerParams(args [1]string, r *http.Request) (params GetAccountStateLiteServerParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetAccountTransactionsParams is parameters of getAccountTransactions operation.
type GetAccountTransactionsParams struct {
	// Account ID.
	AccountID string
	// Omit this parameter to get last transactions.
	AfterLt OptInt64
	// Omit this parameter to get last transactions.
	BeforeLt OptInt64
	Limit    OptInt32
}

func unpackGetAccountTransactionsParams(packed middleware.Parameters) (params GetAccountTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "after_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AfterLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	return params
}

func decodeGetAccountTransactionsParams(args [1]string, r *http.Request) (params GetAccountTransactionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode query: after_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotAfterLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AfterLt.SetTo(paramsDotAfterLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: after_lt: parse")
			}
		}
	}
	// Decode query: before_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before_lt: parse")
			}
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	return params, nil
}

// GetAllAuctionsParams is parameters of getAllAuctions operation.
type GetAllAuctionsParams struct {
	// Domain filter for current auctions "ton" or "t.me".
	Tld OptString
}

func unpackGetAllAuctionsParams(packed middleware.Parameters) (params GetAllAuctionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "tld",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tld = v.(OptString)
		}
	}
	return params
}

func decodeGetAllAuctionsParams(args [0]string, r *http.Request) (params GetAllAuctionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: tld.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tld",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTldVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTldVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Tld.SetTo(paramsDotTldVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tld: parse")
			}
		}
	}
	return params, nil
}

// GetAllShardsInfoLiteServerParams is parameters of getAllShardsInfoLiteServer operation.
type GetAllShardsInfoLiteServerParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
}

func unpackGetAllShardsInfoLiteServerParams(packed middleware.Parameters) (params GetAllShardsInfoLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetAllShardsInfoLiteServerParams(args [1]string, r *http.Request) (params GetAllShardsInfoLiteServerParams, _ error) {
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	return params, nil
}

// GetBlockParams is parameters of getBlock operation.
type GetBlockParams struct {
	// Block ID.
	BlockID string
}

func unpackGetBlockParams(packed middleware.Parameters) (params GetBlockParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetBlockParams(args [1]string, r *http.Request) (params GetBlockParams, _ error) {
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	return params, nil
}

// GetBlockHeaderLiteServerParams is parameters of getBlockHeaderLiteServer operation.
type GetBlockHeaderLiteServerParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
	// Mode.
	Mode uint32
}

func unpackGetBlockHeaderLiteServerParams(packed middleware.Parameters) (params GetBlockHeaderLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mode",
			In:   "query",
		}
		params.Mode = packed[key].(uint32)
	}
	return params
}

func decodeGetBlockHeaderLiteServerParams(args [1]string, r *http.Request) (params GetBlockHeaderLiteServerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	// Decode query: mode.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUint32(val)
				if err != nil {
					return err
				}

				params.Mode = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: mode: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// GetBlockLiteServerParams is parameters of getBlockLiteServer operation.
type GetBlockLiteServerParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
}

func unpackGetBlockLiteServerParams(packed middleware.Parameters) (params GetBlockLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetBlockLiteServerParams(args [1]string, r *http.Request) (params GetBlockLiteServerParams, _ error) {
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	return params, nil
}

// GetBlockProofLiteServerParams is parameters of getBlockProofLiteServer operation.
type GetBlockProofLiteServerParams struct {
	// Known block: (workchain,shard,seqno,root_hash,file_hash).
	KnownBlock string
	// Target block: (workchain,shard,seqno,root_hash,file_hash).
	TargetBlock OptString
	// Mode.
	Mode uint32
}

func unpackGetBlockProofLiteServerParams(packed middleware.Parameters) (params GetBlockProofLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "known_block",
			In:   "query",
		}
		params.KnownBlock = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "target_block",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TargetBlock = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "mode",
			In:   "query",
		}
		params.Mode = packed[key].(uint32)
	}
	return params
}

func decodeGetBlockProofLiteServerParams(args [0]string, r *http.Request) (params GetBlockProofLiteServerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: known_block.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "known_block",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.KnownBlock = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: known_block: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: target_block.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "target_block",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTargetBlockVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTargetBlockVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TargetBlock.SetTo(paramsDotTargetBlockVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: target_block: parse")
			}
		}
	}
	// Decode query: mode.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUint32(val)
				if err != nil {
					return err
				}

				params.Mode = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: mode: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// GetBlockTransactionsParams is parameters of getBlockTransactions operation.
type GetBlockTransactionsParams struct {
	// Block ID.
	BlockID string
}

func unpackGetBlockTransactionsParams(packed middleware.Parameters) (params GetBlockTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetBlockTransactionsParams(args [1]string, r *http.Request) (params GetBlockTransactionsParams, _ error) {
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	return params, nil
}

// GetConfigAllLiteServerParams is parameters of getConfigAllLiteServer operation.
type GetConfigAllLiteServerParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
	// Mode.
	Mode uint32
}

func unpackGetConfigAllLiteServerParams(packed middleware.Parameters) (params GetConfigAllLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mode",
			In:   "query",
		}
		params.Mode = packed[key].(uint32)
	}
	return params
}

func decodeGetConfigAllLiteServerParams(args [1]string, r *http.Request) (params GetConfigAllLiteServerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	// Decode query: mode.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUint32(val)
				if err != nil {
					return err
				}

				params.Mode = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: mode: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// GetDnsExpiringParams is parameters of getDnsExpiring operation.
type GetDnsExpiringParams struct {
	// Account ID.
	AccountID string
	// Number of days before expiration.
	Period OptInt
}

func unpackGetDnsExpiringParams(packed middleware.Parameters) (params GetDnsExpiringParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "period",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Period = v.(OptInt)
		}
	}
	return params
}

func decodeGetDnsExpiringParams(args [1]string, r *http.Request) (params GetDnsExpiringParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode query: period.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "period",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPeriodVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPeriodVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Period.SetTo(paramsDotPeriodVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: period: parse")
			}
			if err := func() error {
				if params.Period.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           3660,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Period.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: period: invalid")
			}
		}
	}
	return params, nil
}

// GetDomainBidsParams is parameters of getDomainBids operation.
type GetDomainBidsParams struct {
	// Domain name with .ton or .t.me.
	DomainName string
}

func unpackGetDomainBidsParams(packed middleware.Parameters) (params GetDomainBidsParams) {
	{
		key := middleware.ParameterKey{
			Name: "domain_name",
			In:   "path",
		}
		params.DomainName = packed[key].(string)
	}
	return params
}

func decodeGetDomainBidsParams(args [1]string, r *http.Request) (params GetDomainBidsParams, _ error) {
	// Decode path: domain_name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domain_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: domain_name: parse")
			}
		} else {
			return params, errors.New("path: domain_name: not specified")
		}
	}
	return params, nil
}

// GetEventParams is parameters of getEvent operation.
type GetEventParams struct {
	// Event ID or transaction hash in hex (without 0x) or base64url format.
	EventID        string
	AcceptLanguage OptString
}

func unpackGetEventParams(packed middleware.Parameters) (params GetEventParams) {
	{
		key := middleware.ParameterKey{
			Name: "event_id",
			In:   "path",
		}
		params.EventID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeGetEventParams(args [1]string, r *http.Request) (params GetEventParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: event_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "event_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EventID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: event_id: parse")
			}
		} else {
			return params, errors.New("path: event_id: not specified")
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	return params, nil
}

// GetEventsByAccountParams is parameters of getEventsByAccount operation.
type GetEventsByAccountParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
	// Filter actions where requested account is not real subject (for example sender or reciver jettons).
	SubjectOnly OptBool
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetEventsByAccountParams(packed middleware.Parameters) (params GetEventsByAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "subject_only",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SubjectOnly = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetEventsByAccountParams(args [1]string, r *http.Request) (params GetEventsByAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	// Set default value for query: subject_only.
	{
		val := bool(false)
		params.SubjectOnly.SetTo(val)
	}
	// Decode query: subject_only.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "subject_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSubjectOnlyVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSubjectOnlyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SubjectOnly.SetTo(paramsDotSubjectOnlyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: subject_only: parse")
			}
		}
	}
	// Decode query: before_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before_lt: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        false,
					Min:           0,
					MaxSet:        true,
					Max:           1000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: start_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: start_date: parse")
			}
		}
	}
	// Decode query: end_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: end_date: parse")
			}
		}
	}
	return params, nil
}

// GetItemsFromCollectionParams is parameters of getItemsFromCollection operation.
type GetItemsFromCollectionParams struct {
	// Account ID.
	AccountID string
	Limit     OptInt
	Offset    OptInt
}

func unpackGetItemsFromCollectionParams(packed middleware.Parameters) (params GetItemsFromCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetItemsFromCollectionParams(args [1]string, r *http.Request) (params GetItemsFromCollectionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Set default value for query: limit.
	{
		val := int(1000)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

// GetJettonInfoParams is parameters of getJettonInfo operation.
type GetJettonInfoParams struct {
	// Account ID.
	AccountID string
}

func unpackGetJettonInfoParams(packed middleware.Parameters) (params GetJettonInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetJettonInfoParams(args [1]string, r *http.Request) (params GetJettonInfoParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetJettonsParams is parameters of getJettons operation.
type GetJettonsParams struct {
	Limit  OptInt32
	Offset OptInt32
}

func unpackGetJettonsParams(packed middleware.Parameters) (params GetJettonsParams) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	return params
}

func decodeGetJettonsParams(args [0]string, r *http.Request) (params GetJettonsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

// GetJettonsBalancesParams is parameters of getJettonsBalances operation.
type GetJettonsBalancesParams struct {
	// Account ID.
	AccountID string
}

func unpackGetJettonsBalancesParams(packed middleware.Parameters) (params GetJettonsBalancesParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetJettonsBalancesParams(args [1]string, r *http.Request) (params GetJettonsBalancesParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetJettonsHistoryParams is parameters of getJettonsHistory operation.
type GetJettonsHistoryParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetJettonsHistoryParams(packed middleware.Parameters) (params GetJettonsHistoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetJettonsHistoryParams(args [1]string, r *http.Request) (params GetJettonsHistoryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	// Decode query: before_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before_lt: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        false,
					Min:           0,
					MaxSet:        true,
					Max:           1000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: start_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: start_date: parse")
			}
		}
	}
	// Decode query: end_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: end_date: parse")
			}
		}
	}
	return params, nil
}

// GetJettonsHistoryByIDParams is parameters of getJettonsHistoryByID operation.
type GetJettonsHistoryByIDParams struct {
	// Account ID.
	AccountID string
	// Jetton ID.
	JettonID       string
	AcceptLanguage OptString
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetJettonsHistoryByIDParams(packed middleware.Parameters) (params GetJettonsHistoryByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "jetton_id",
			In:   "path",
		}
		params.JettonID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetJettonsHistoryByIDParams(args [2]string, r *http.Request) (params GetJettonsHistoryByIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode path: jetton_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jetton_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JettonID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: jetton_id: parse")
			}
		} else {
			return params, errors.New("path: jetton_id: not specified")
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	// Decode query: before_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before_lt: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        false,
					Min:           0,
					MaxSet:        true,
					Max:           1000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: start_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: start_date: parse")
			}
		}
	}
	// Decode query: end_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: end_date: parse")
			}
		}
	}
	return params, nil
}

// GetListBlockTransactionsLiteServerParams is parameters of getListBlockTransactionsLiteServer operation.
type GetListBlockTransactionsLiteServerParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
	// Mode.
	Mode uint32
	// Count.
	Count uint32
	// Account ID.
	AccountID OptString
	// Lt.
	Lt OptUint64
}

func unpackGetListBlockTransactionsLiteServerParams(packed middleware.Parameters) (params GetListBlockTransactionsLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mode",
			In:   "query",
		}
		params.Mode = packed[key].(uint32)
	}
	{
		key := middleware.ParameterKey{
			Name: "count",
			In:   "query",
		}
		params.Count = packed[key].(uint32)
	}
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AccountID = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Lt = v.(OptUint64)
		}
	}
	return params
}

func decodeGetListBlockTransactionsLiteServerParams(args [1]string, r *http.Request) (params GetListBlockTransactionsLiteServerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	// Decode query: mode.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUint32(val)
				if err != nil {
					return err
				}

				params.Mode = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: mode: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: count.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUint32(val)
				if err != nil {
					return err
				}

				params.Count = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: count: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: account_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "account_id",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAccountIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAccountIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AccountID.SetTo(paramsDotAccountIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: account_id: parse")
			}
		}
	}
	// Decode query: lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLtVal uint64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUint64(val)
					if err != nil {
						return err
					}

					paramsDotLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Lt.SetTo(paramsDotLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: lt: parse")
			}
		}
	}
	return params, nil
}

// GetMasterchainInfoExtLiteServerParams is parameters of getMasterchainInfoExtLiteServer operation.
type GetMasterchainInfoExtLiteServerParams struct {
	// Mode.
	Mode uint32
}

func unpackGetMasterchainInfoExtLiteServerParams(packed middleware.Parameters) (params GetMasterchainInfoExtLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "mode",
			In:   "query",
		}
		params.Mode = packed[key].(uint32)
	}
	return params
}

func decodeGetMasterchainInfoExtLiteServerParams(args [0]string, r *http.Request) (params GetMasterchainInfoExtLiteServerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: mode.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUint32(val)
				if err != nil {
					return err
				}

				params.Mode = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: mode: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// GetNftCollectionParams is parameters of getNftCollection operation.
type GetNftCollectionParams struct {
	// Account ID.
	AccountID string
}

func unpackGetNftCollectionParams(packed middleware.Parameters) (params GetNftCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetNftCollectionParams(args [1]string, r *http.Request) (params GetNftCollectionParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetNftCollectionsParams is parameters of getNftCollections operation.
type GetNftCollectionsParams struct {
	Limit  OptInt32
	Offset OptInt32
}

func unpackGetNftCollectionsParams(packed middleware.Parameters) (params GetNftCollectionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	return params
}

func decodeGetNftCollectionsParams(args [0]string, r *http.Request) (params GetNftCollectionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

// GetNftItemByAddressParams is parameters of getNftItemByAddress operation.
type GetNftItemByAddressParams struct {
	// Account ID.
	AccountID string
}

func unpackGetNftItemByAddressParams(packed middleware.Parameters) (params GetNftItemByAddressParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetNftItemByAddressParams(args [1]string, r *http.Request) (params GetNftItemByAddressParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetNftItemsByOwnerParams is parameters of getNftItemsByOwner operation.
type GetNftItemsByOwnerParams struct {
	// Account ID.
	AccountID string
	// Nft collection.
	Collection OptString
	Limit      OptInt
	Offset     OptInt
	// Selling nft items in ton implemented usually via transfer items to special selling account. This
	// option enables including items which owned not directly.
	IndirectOwnership OptBool
}

func unpackGetNftItemsByOwnerParams(packed middleware.Parameters) (params GetNftItemsByOwnerParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "collection",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Collection = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "indirect_ownership",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IndirectOwnership = v.(OptBool)
		}
	}
	return params
}

func decodeGetNftItemsByOwnerParams(args [1]string, r *http.Request) (params GetNftItemsByOwnerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode query: collection.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "collection",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCollectionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCollectionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Collection.SetTo(paramsDotCollectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: collection: parse")
			}
		}
	}
	// Set default value for query: limit.
	{
		val := int(1000)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	// Set default value for query: indirect_ownership.
	{
		val := bool(false)
		params.IndirectOwnership.SetTo(val)
	}
	// Decode query: indirect_ownership.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "indirect_ownership",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIndirectOwnershipVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIndirectOwnershipVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IndirectOwnership.SetTo(paramsDotIndirectOwnershipVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: indirect_ownership: parse")
			}
		}
	}
	return params, nil
}

// GetPublicKeyByAccountIDParams is parameters of getPublicKeyByAccountID operation.
type GetPublicKeyByAccountIDParams struct {
	// Account ID.
	AccountID string
}

func unpackGetPublicKeyByAccountIDParams(packed middleware.Parameters) (params GetPublicKeyByAccountIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetPublicKeyByAccountIDParams(args [1]string, r *http.Request) (params GetPublicKeyByAccountIDParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetRatesParams is parameters of getRates operation.
type GetRatesParams struct {
	// Accept ton and jetton master addresses, separated by commas.
	Tokens string
	// Accept ton and all possible fiat currencies, separated by commas.
	Currencies string
}

func unpackGetRatesParams(packed middleware.Parameters) (params GetRatesParams) {
	{
		key := middleware.ParameterKey{
			Name: "tokens",
			In:   "query",
		}
		params.Tokens = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "currencies",
			In:   "query",
		}
		params.Currencies = packed[key].(string)
	}
	return params
}

func decodeGetRatesParams(args [0]string, r *http.Request) (params GetRatesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: tokens.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tokens",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Tokens = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tokens: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: currencies.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "currencies",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Currencies = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: currencies: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// GetRawAccountParams is parameters of getRawAccount operation.
type GetRawAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetRawAccountParams(packed middleware.Parameters) (params GetRawAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetRawAccountParams(args [1]string, r *http.Request) (params GetRawAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetSearchAccountsParams is parameters of getSearchAccounts operation.
type GetSearchAccountsParams struct {
	Name string
}

func unpackGetSearchAccountsParams(packed middleware.Parameters) (params GetSearchAccountsParams) {
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeGetSearchAccountsParams(args [0]string, r *http.Request) (params GetSearchAccountsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: name: parse")
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    3,
					MinLengthSet: true,
					MaxLength:    15,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Name)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: name: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// GetShardBlockProofLiteServerParams is parameters of getShardBlockProofLiteServer operation.
type GetShardBlockProofLiteServerParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
}

func unpackGetShardBlockProofLiteServerParams(packed middleware.Parameters) (params GetShardBlockProofLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetShardBlockProofLiteServerParams(args [1]string, r *http.Request) (params GetShardBlockProofLiteServerParams, _ error) {
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	return params, nil
}

// GetShardInfoLiteServerParams is parameters of getShardInfoLiteServer operation.
type GetShardInfoLiteServerParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
	// Workchain.
	Workchain uint32
	// Shard.
	Shard uint64
	// Exact.
	Exact bool
}

func unpackGetShardInfoLiteServerParams(packed middleware.Parameters) (params GetShardInfoLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "workchain",
			In:   "query",
		}
		params.Workchain = packed[key].(uint32)
	}
	{
		key := middleware.ParameterKey{
			Name: "shard",
			In:   "query",
		}
		params.Shard = packed[key].(uint64)
	}
	{
		key := middleware.ParameterKey{
			Name: "exact",
			In:   "query",
		}
		params.Exact = packed[key].(bool)
	}
	return params
}

func decodeGetShardInfoLiteServerParams(args [1]string, r *http.Request) (params GetShardInfoLiteServerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	// Decode query: workchain.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "workchain",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUint32(val)
				if err != nil {
					return err
				}

				params.Workchain = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: workchain: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: shard.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "shard",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUint64(val)
				if err != nil {
					return err
				}

				params.Shard = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: shard: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: exact.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exact",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToBool(val)
				if err != nil {
					return err
				}

				params.Exact = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: exact: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// GetStateLiteServerParams is parameters of getStateLiteServer operation.
type GetStateLiteServerParams struct {
	// Block ID: (workchain,shard,seqno,root_hash,file_hash).
	BlockID string
}

func unpackGetStateLiteServerParams(packed middleware.Parameters) (params GetStateLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetStateLiteServerParams(args [1]string, r *http.Request) (params GetStateLiteServerParams, _ error) {
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	return params, nil
}

// GetSubscriptionsByAccountParams is parameters of getSubscriptionsByAccount operation.
type GetSubscriptionsByAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetSubscriptionsByAccountParams(packed middleware.Parameters) (params GetSubscriptionsByAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetSubscriptionsByAccountParams(args [1]string, r *http.Request) (params GetSubscriptionsByAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetTraceParams is parameters of getTrace operation.
type GetTraceParams struct {
	// Trace ID or transaction hash in hex (without 0x) or base64url format.
	TraceID string
}

func unpackGetTraceParams(packed middleware.Parameters) (params GetTraceParams) {
	{
		key := middleware.ParameterKey{
			Name: "trace_id",
			In:   "path",
		}
		params.TraceID = packed[key].(string)
	}
	return params
}

func decodeGetTraceParams(args [1]string, r *http.Request) (params GetTraceParams, _ error) {
	// Decode path: trace_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "trace_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TraceID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: trace_id: parse")
			}
		} else {
			return params, errors.New("path: trace_id: not specified")
		}
	}
	return params, nil
}

// GetTracesByAccountParams is parameters of getTracesByAccount operation.
type GetTracesByAccountParams struct {
	// Account ID.
	AccountID string
	Limit     OptInt32
}

func unpackGetTracesByAccountParams(packed middleware.Parameters) (params GetTracesByAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	return params
}

func decodeGetTracesByAccountParams(args [1]string, r *http.Request) (params GetTracesByAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	return params, nil
}

// GetTransactionParams is parameters of getTransaction operation.
type GetTransactionParams struct {
	// Transaction ID.
	TransactionID string
}

func unpackGetTransactionParams(packed middleware.Parameters) (params GetTransactionParams) {
	{
		key := middleware.ParameterKey{
			Name: "transaction_id",
			In:   "path",
		}
		params.TransactionID = packed[key].(string)
	}
	return params
}

func decodeGetTransactionParams(args [1]string, r *http.Request) (params GetTransactionParams, _ error) {
	// Decode path: transaction_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "transaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TransactionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: transaction_id: parse")
			}
		} else {
			return params, errors.New("path: transaction_id: not specified")
		}
	}
	return params, nil
}

// GetTransactionByMessageHashParams is parameters of getTransactionByMessageHash operation.
type GetTransactionByMessageHashParams struct {
	// Message ID.
	MsgID string
}

func unpackGetTransactionByMessageHashParams(packed middleware.Parameters) (params GetTransactionByMessageHashParams) {
	{
		key := middleware.ParameterKey{
			Name: "msg_id",
			In:   "path",
		}
		params.MsgID = packed[key].(string)
	}
	return params
}

func decodeGetTransactionByMessageHashParams(args [1]string, r *http.Request) (params GetTransactionByMessageHashParams, _ error) {
	// Decode path: msg_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "msg_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MsgID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: msg_id: parse")
			}
		} else {
			return params, errors.New("path: msg_id: not specified")
		}
	}
	return params, nil
}

// GetTransactionsLiteServerParams is parameters of getTransactionsLiteServer operation.
type GetTransactionsLiteServerParams struct {
	// Account ID.
	AccountID string
	// Count.
	Count uint32
	// Lt.
	Lt uint64
	// Hash.
	Hash string
}

func unpackGetTransactionsLiteServerParams(packed middleware.Parameters) (params GetTransactionsLiteServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "count",
			In:   "query",
		}
		params.Count = packed[key].(uint32)
	}
	{
		key := middleware.ParameterKey{
			Name: "lt",
			In:   "query",
		}
		params.Lt = packed[key].(uint64)
	}
	{
		key := middleware.ParameterKey{
			Name: "hash",
			In:   "query",
		}
		params.Hash = packed[key].(string)
	}
	return params
}

func decodeGetTransactionsLiteServerParams(args [1]string, r *http.Request) (params GetTransactionsLiteServerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode query: count.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUint32(val)
				if err != nil {
					return err
				}

				params.Count = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: count: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUint64(val)
				if err != nil {
					return err
				}

				params.Lt = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: lt: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: hash.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "hash",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Hash = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: hash: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// GetWalletBackupParams is parameters of getWalletBackup operation.
type GetWalletBackupParams struct {
	XTonConnectAuth string
}

func unpackGetWalletBackupParams(packed middleware.Parameters) (params GetWalletBackupParams) {
	{
		key := middleware.ParameterKey{
			Name: "X-TonConnect-Auth",
			In:   "header",
		}
		params.XTonConnectAuth = packed[key].(string)
	}
	return params
}

func decodeGetWalletBackupParams(args [0]string, r *http.Request) (params GetWalletBackupParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: X-TonConnect-Auth.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "X-TonConnect-Auth",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.XTonConnectAuth = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: X-TonConnect-Auth: parse")
			}
		} else {
			return params, errors.New("header: X-TonConnect-Auth: not specified")
		}
	}
	return params, nil
}

// GetWalletsByPublicKeyParams is parameters of getWalletsByPublicKey operation.
type GetWalletsByPublicKeyParams struct {
	PublicKey string
}

func unpackGetWalletsByPublicKeyParams(packed middleware.Parameters) (params GetWalletsByPublicKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "public_key",
			In:   "path",
		}
		params.PublicKey = packed[key].(string)
	}
	return params
}

func decodeGetWalletsByPublicKeyParams(args [1]string, r *http.Request) (params GetWalletsByPublicKeyParams, _ error) {
	// Decode path: public_key.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "public_key",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PublicKey = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: public_key: parse")
			}
		} else {
			return params, errors.New("path: public_key: not specified")
		}
	}
	return params, nil
}

// PoolsByNominatorsParams is parameters of poolsByNominators operation.
type PoolsByNominatorsParams struct {
	// Account ID.
	AccountID string
}

func unpackPoolsByNominatorsParams(packed middleware.Parameters) (params PoolsByNominatorsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodePoolsByNominatorsParams(args [1]string, r *http.Request) (params PoolsByNominatorsParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// ReindexAccountParams is parameters of reindexAccount operation.
type ReindexAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackReindexAccountParams(packed middleware.Parameters) (params ReindexAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeReindexAccountParams(args [1]string, r *http.Request) (params ReindexAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// SetWalletBackupParams is parameters of setWalletBackup operation.
type SetWalletBackupParams struct {
	XTonConnectAuth string
}

func unpackSetWalletBackupParams(packed middleware.Parameters) (params SetWalletBackupParams) {
	{
		key := middleware.ParameterKey{
			Name: "X-TonConnect-Auth",
			In:   "header",
		}
		params.XTonConnectAuth = packed[key].(string)
	}
	return params
}

func decodeSetWalletBackupParams(args [0]string, r *http.Request) (params SetWalletBackupParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: X-TonConnect-Auth.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "X-TonConnect-Auth",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.XTonConnectAuth = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: X-TonConnect-Auth: parse")
			}
		} else {
			return params, errors.New("header: X-TonConnect-Auth: not specified")
		}
	}
	return params, nil
}

// StakingPoolHistoryParams is parameters of stakingPoolHistory operation.
type StakingPoolHistoryParams struct {
	// Account ID.
	AccountID string
}

func unpackStakingPoolHistoryParams(packed middleware.Parameters) (params StakingPoolHistoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeStakingPoolHistoryParams(args [1]string, r *http.Request) (params StakingPoolHistoryParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// StakingPoolInfoParams is parameters of stakingPoolInfo operation.
type StakingPoolInfoParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
}

func unpackStakingPoolInfoParams(packed middleware.Parameters) (params StakingPoolInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeStakingPoolInfoParams(args [1]string, r *http.Request) (params StakingPoolInfoParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	return params, nil
}

// StakingPoolsParams is parameters of stakingPools operation.
type StakingPoolsParams struct {
	// Account ID.
	AvailableFor OptString
	// Return also pools not from white list - just compatible by interfaces (maybe dangerous!).
	IncludeUnverified OptBool
	AcceptLanguage    OptString
}

func unpackStakingPoolsParams(packed middleware.Parameters) (params StakingPoolsParams) {
	{
		key := middleware.ParameterKey{
			Name: "available_for",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AvailableFor = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "include_unverified",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludeUnverified = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeStakingPoolsParams(args [0]string, r *http.Request) (params StakingPoolsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode query: available_for.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "available_for",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAvailableForVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAvailableForVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AvailableFor.SetTo(paramsDotAvailableForVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: available_for: parse")
			}
		}
	}
	// Decode query: include_unverified.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include_unverified",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeUnverifiedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIncludeUnverifiedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IncludeUnverified.SetTo(paramsDotIncludeUnverifiedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: include_unverified: parse")
			}
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	return params, nil
}
