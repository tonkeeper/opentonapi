// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"net/http"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// DnsBackResolveParams is parameters of dnsBackResolve operation.
type DnsBackResolveParams struct {
	// Account ID.
	AccountID string
}

func unpackDnsBackResolveParams(packed middleware.Parameters) (params DnsBackResolveParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeDnsBackResolveParams(args [1]string, r *http.Request) (params DnsBackResolveParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// DnsResolveParams is parameters of dnsResolve operation.
type DnsResolveParams struct {
	// Domain name with .ton or .t.me.
	DomainName string
}

func unpackDnsResolveParams(packed middleware.Parameters) (params DnsResolveParams) {
	{
		key := middleware.ParameterKey{
			Name: "domain_name",
			In:   "path",
		}
		params.DomainName = packed[key].(string)
	}
	return params
}

func decodeDnsResolveParams(args [1]string, r *http.Request) (params DnsResolveParams, _ error) {
	// Decode path: domain_name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domain_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: domain_name: parse")
			}
		} else {
			return params, errors.New("path: domain_name: not specified")
		}
	}
	return params, nil
}

// ExecGetMethodParams is parameters of execGetMethod operation.
type ExecGetMethodParams struct {
	// Account ID.
	AccountID string
	// Contract get method name.
	MethodName string
	Args       []string
}

func unpackExecGetMethodParams(packed middleware.Parameters) (params ExecGetMethodParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "method_name",
			In:   "path",
		}
		params.MethodName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "args",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Args = v.([]string)
		}
	}
	return params
}

func decodeExecGetMethodParams(args [2]string, r *http.Request) (params ExecGetMethodParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode path: method_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "method_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MethodName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: method_name: parse")
			}
		} else {
			return params, errors.New("path: method_name: not specified")
		}
	}
	// Decode query: args.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "args",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotArgsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotArgsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Args = append(params.Args, paramsDotArgsVal)
					return nil
				})
			}); err != nil {
				return params, errors.Wrap(err, "query: args: parse")
			}
		}
	}
	return params, nil
}

// GetAccountParams is parameters of getAccount operation.
type GetAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetAccountParams(packed middleware.Parameters) (params GetAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetAccountParams(args [1]string, r *http.Request) (params GetAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetAccountTransactionsParams is parameters of getAccountTransactions operation.
type GetAccountTransactionsParams struct {
	// Account ID.
	AccountID string
	// Omit this parameter to get last transactions.
	AfterLt OptInt64
	// Omit this parameter to get last transactions.
	BeforeLt OptInt64
	Limit    OptInt32
}

func unpackGetAccountTransactionsParams(packed middleware.Parameters) (params GetAccountTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "after_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AfterLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	return params
}

func decodeGetAccountTransactionsParams(args [1]string, r *http.Request) (params GetAccountTransactionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode query: after_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotAfterLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AfterLt.SetTo(paramsDotAfterLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: after_lt: parse")
			}
		}
	}
	// Decode query: before_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before_lt: parse")
			}
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	return params, nil
}

// GetAllAuctionsParams is parameters of getAllAuctions operation.
type GetAllAuctionsParams struct {
	// Domain filter for current auctions "ton" or "t.me".
	Tld OptString
}

func unpackGetAllAuctionsParams(packed middleware.Parameters) (params GetAllAuctionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "tld",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tld = v.(OptString)
		}
	}
	return params
}

func decodeGetAllAuctionsParams(args [0]string, r *http.Request) (params GetAllAuctionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: tld.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tld",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTldVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTldVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Tld.SetTo(paramsDotTldVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tld: parse")
			}
		}
	}
	return params, nil
}

// GetBlockParams is parameters of getBlock operation.
type GetBlockParams struct {
	// Block ID.
	BlockID string
}

func unpackGetBlockParams(packed middleware.Parameters) (params GetBlockParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetBlockParams(args [1]string, r *http.Request) (params GetBlockParams, _ error) {
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	return params, nil
}

// GetBlockTransactionsParams is parameters of getBlockTransactions operation.
type GetBlockTransactionsParams struct {
	// Block ID.
	BlockID string
}

func unpackGetBlockTransactionsParams(packed middleware.Parameters) (params GetBlockTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetBlockTransactionsParams(args [1]string, r *http.Request) (params GetBlockTransactionsParams, _ error) {
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	return params, nil
}

// GetDomainBidsParams is parameters of getDomainBids operation.
type GetDomainBidsParams struct {
	// Domain name with .ton or .t.me.
	DomainName string
}

func unpackGetDomainBidsParams(packed middleware.Parameters) (params GetDomainBidsParams) {
	{
		key := middleware.ParameterKey{
			Name: "domain_name",
			In:   "path",
		}
		params.DomainName = packed[key].(string)
	}
	return params
}

func decodeGetDomainBidsParams(args [1]string, r *http.Request) (params GetDomainBidsParams, _ error) {
	// Decode path: domain_name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domain_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: domain_name: parse")
			}
		} else {
			return params, errors.New("path: domain_name: not specified")
		}
	}
	return params, nil
}

// GetEventParams is parameters of getEvent operation.
type GetEventParams struct {
	// Event ID or transaction hash in hex (without 0x) or base64url format.
	EventID string
}

func unpackGetEventParams(packed middleware.Parameters) (params GetEventParams) {
	{
		key := middleware.ParameterKey{
			Name: "event_id",
			In:   "path",
		}
		params.EventID = packed[key].(string)
	}
	return params
}

func decodeGetEventParams(args [1]string, r *http.Request) (params GetEventParams, _ error) {
	// Decode path: event_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "event_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EventID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: event_id: parse")
			}
		} else {
			return params, errors.New("path: event_id: not specified")
		}
	}
	return params, nil
}

// GetEventsByAccountParams is parameters of getEventsByAccount operation.
type GetEventsByAccountParams struct {
	// Account ID.
	AccountID string
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetEventsByAccountParams(packed middleware.Parameters) (params GetEventsByAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetEventsByAccountParams(args [1]string, r *http.Request) (params GetEventsByAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode query: before_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before_lt: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        false,
					Min:           0,
					MaxSet:        true,
					Max:           1000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: start_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: start_date: parse")
			}
		}
	}
	// Decode query: end_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: end_date: parse")
			}
		}
	}
	return params, nil
}

// GetItemsFromCollectionParams is parameters of getItemsFromCollection operation.
type GetItemsFromCollectionParams struct {
	// Account ID.
	AccountID string
	Limit     OptInt
	Offset    OptInt
}

func unpackGetItemsFromCollectionParams(packed middleware.Parameters) (params GetItemsFromCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetItemsFromCollectionParams(args [1]string, r *http.Request) (params GetItemsFromCollectionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Set default value for query: limit.
	{
		val := int(1000)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

// GetJettonInfoParams is parameters of getJettonInfo operation.
type GetJettonInfoParams struct {
	// Account ID.
	AccountID string
}

func unpackGetJettonInfoParams(packed middleware.Parameters) (params GetJettonInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetJettonInfoParams(args [1]string, r *http.Request) (params GetJettonInfoParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetJettonsBalancesParams is parameters of getJettonsBalances operation.
type GetJettonsBalancesParams struct {
	// Account ID.
	AccountID string
}

func unpackGetJettonsBalancesParams(packed middleware.Parameters) (params GetJettonsBalancesParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetJettonsBalancesParams(args [1]string, r *http.Request) (params GetJettonsBalancesParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetJettonsHistoryParams is parameters of getJettonsHistory operation.
type GetJettonsHistoryParams struct {
	// Account ID.
	AccountID string
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetJettonsHistoryParams(packed middleware.Parameters) (params GetJettonsHistoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetJettonsHistoryParams(args [1]string, r *http.Request) (params GetJettonsHistoryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode query: before_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before_lt: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        false,
					Min:           0,
					MaxSet:        true,
					Max:           1000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: start_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: start_date: parse")
			}
		}
	}
	// Decode query: end_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: end_date: parse")
			}
		}
	}
	return params, nil
}

// GetNftCollectionParams is parameters of getNftCollection operation.
type GetNftCollectionParams struct {
	// Account ID.
	AccountID string
}

func unpackGetNftCollectionParams(packed middleware.Parameters) (params GetNftCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetNftCollectionParams(args [1]string, r *http.Request) (params GetNftCollectionParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetNftCollectionsParams is parameters of getNftCollections operation.
type GetNftCollectionsParams struct {
	Limit  OptInt32
	Offset OptInt32
}

func unpackGetNftCollectionsParams(packed middleware.Parameters) (params GetNftCollectionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	return params
}

func decodeGetNftCollectionsParams(args [0]string, r *http.Request) (params GetNftCollectionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

// GetNftItemByAddressParams is parameters of getNftItemByAddress operation.
type GetNftItemByAddressParams struct {
	// Account ID.
	AccountID string
}

func unpackGetNftItemByAddressParams(packed middleware.Parameters) (params GetNftItemByAddressParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetNftItemByAddressParams(args [1]string, r *http.Request) (params GetNftItemByAddressParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetNftItemsByOwnerParams is parameters of getNftItemsByOwner operation.
type GetNftItemsByOwnerParams struct {
	// Account ID.
	AccountID string
	Limit     OptInt
	Offset    OptInt
	// Selling nft items in ton implemented usually via transfer items to special selling account. This
	// option enables including items which owned not directly.
	IndirectOwnership OptBool
}

func unpackGetNftItemsByOwnerParams(packed middleware.Parameters) (params GetNftItemsByOwnerParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "indirect_ownership",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IndirectOwnership = v.(OptBool)
		}
	}
	return params
}

func decodeGetNftItemsByOwnerParams(args [1]string, r *http.Request) (params GetNftItemsByOwnerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Set default value for query: limit.
	{
		val := int(1000)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	// Set default value for query: indirect_ownership.
	{
		val := bool(false)
		params.IndirectOwnership.SetTo(val)
	}
	// Decode query: indirect_ownership.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "indirect_ownership",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIndirectOwnershipVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIndirectOwnershipVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IndirectOwnership.SetTo(paramsDotIndirectOwnershipVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: indirect_ownership: parse")
			}
		}
	}
	return params, nil
}

// GetRatesParams is parameters of getRates operation.
type GetRatesParams struct {
	// Accept ton and jetton master addresses, separated by commas.
	Tokens string
	// Accept ton and all possible fiat currencies, separated by commas.
	Currencies string
}

func unpackGetRatesParams(packed middleware.Parameters) (params GetRatesParams) {
	{
		key := middleware.ParameterKey{
			Name: "tokens",
			In:   "query",
		}
		params.Tokens = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "currencies",
			In:   "query",
		}
		params.Currencies = packed[key].(string)
	}
	return params
}

func decodeGetRatesParams(args [0]string, r *http.Request) (params GetRatesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: tokens.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tokens",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Tokens = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tokens: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: currencies.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "currencies",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Currencies = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: currencies: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// GetRawAccountParams is parameters of getRawAccount operation.
type GetRawAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetRawAccountParams(packed middleware.Parameters) (params GetRawAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetRawAccountParams(args [1]string, r *http.Request) (params GetRawAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetSubscriptionsByAccountParams is parameters of getSubscriptionsByAccount operation.
type GetSubscriptionsByAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetSubscriptionsByAccountParams(packed middleware.Parameters) (params GetSubscriptionsByAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetSubscriptionsByAccountParams(args [1]string, r *http.Request) (params GetSubscriptionsByAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetTraceParams is parameters of getTrace operation.
type GetTraceParams struct {
	// Trace ID or transaction hash in hex (without 0x) or base64url format.
	TraceID string
}

func unpackGetTraceParams(packed middleware.Parameters) (params GetTraceParams) {
	{
		key := middleware.ParameterKey{
			Name: "trace_id",
			In:   "path",
		}
		params.TraceID = packed[key].(string)
	}
	return params
}

func decodeGetTraceParams(args [1]string, r *http.Request) (params GetTraceParams, _ error) {
	// Decode path: trace_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "trace_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TraceID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: trace_id: parse")
			}
		} else {
			return params, errors.New("path: trace_id: not specified")
		}
	}
	return params, nil
}

// GetTracesByAccountParams is parameters of getTracesByAccount operation.
type GetTracesByAccountParams struct {
	// Account ID.
	AccountID string
	Limit     OptInt32
}

func unpackGetTracesByAccountParams(packed middleware.Parameters) (params GetTracesByAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	return params
}

func decodeGetTracesByAccountParams(args [1]string, r *http.Request) (params GetTracesByAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	return params, nil
}

// GetTransactionParams is parameters of getTransaction operation.
type GetTransactionParams struct {
	// Transaction ID.
	TransactionID string
}

func unpackGetTransactionParams(packed middleware.Parameters) (params GetTransactionParams) {
	{
		key := middleware.ParameterKey{
			Name: "transaction_id",
			In:   "path",
		}
		params.TransactionID = packed[key].(string)
	}
	return params
}

func decodeGetTransactionParams(args [1]string, r *http.Request) (params GetTransactionParams, _ error) {
	// Decode path: transaction_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "transaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TransactionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: transaction_id: parse")
			}
		} else {
			return params, errors.New("path: transaction_id: not specified")
		}
	}
	return params, nil
}

// PoolsByNominatorsParams is parameters of poolsByNominators operation.
type PoolsByNominatorsParams struct {
	// Account ID.
	AccountID string
}

func unpackPoolsByNominatorsParams(packed middleware.Parameters) (params PoolsByNominatorsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodePoolsByNominatorsParams(args [1]string, r *http.Request) (params PoolsByNominatorsParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// StakingPoolInfoParams is parameters of stakingPoolInfo operation.
type StakingPoolInfoParams struct {
	// Account ID.
	AccountID      string
	AcceptLanguage OptString
}

func unpackStakingPoolInfoParams(packed middleware.Parameters) (params StakingPoolInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeStakingPoolInfoParams(args [1]string, r *http.Request) (params StakingPoolInfoParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	return params, nil
}

// StakingPoolsParams is parameters of stakingPools operation.
type StakingPoolsParams struct {
	// Account ID.
	AvailableFor OptString
	// Return also pools not from white list - just compatible by interfaces (maybe dangerous!).
	IncludeUnverified OptBool
	AcceptLanguage    OptString
}

func unpackStakingPoolsParams(packed middleware.Parameters) (params StakingPoolsParams) {
	{
		key := middleware.ParameterKey{
			Name: "available_for",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AvailableFor = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "include_unverified",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludeUnverified = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "Accept-Language",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptLanguage = v.(OptString)
		}
	}
	return params
}

func decodeStakingPoolsParams(args [0]string, r *http.Request) (params StakingPoolsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode query: available_for.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "available_for",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAvailableForVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAvailableForVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AvailableFor.SetTo(paramsDotAvailableForVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: available_for: parse")
			}
		}
	}
	// Decode query: include_unverified.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include_unverified",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeUnverifiedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIncludeUnverifiedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IncludeUnverified.SetTo(paramsDotIncludeUnverifiedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: include_unverified: parse")
			}
		}
	}
	// Set default value for header: Accept-Language.
	{
		val := string("en")
		params.AcceptLanguage.SetTo(val)
	}
	// Decode header: Accept-Language.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Language",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptLanguageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptLanguageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptLanguage.SetTo(paramsDotAcceptLanguageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: Accept-Language: parse")
			}
		}
	}
	return params, nil
}
