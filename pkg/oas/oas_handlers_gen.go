// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"context"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
)

// handleAccountDnsBackResolveRequest handles accountDnsBackResolve operation.
//
// Get account's domains.
//
// GET /v2/accounts/{account_id}/dns/backresolve
func (s *Server) handleAccountDnsBackResolveRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("accountDnsBackResolve"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/dns/backresolve"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AccountDnsBackResolve",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AccountDnsBackResolve",
			ID:   "accountDnsBackResolve",
		}
	)
	params, err := decodeAccountDnsBackResolveParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *DomainNames
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AccountDnsBackResolve",
			OperationSummary: "",
			OperationID:      "accountDnsBackResolve",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AccountDnsBackResolveParams
			Response = *DomainNames
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAccountDnsBackResolveParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AccountDnsBackResolve(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AccountDnsBackResolve(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeAccountDnsBackResolveResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAddressParseRequest handles addressParse operation.
//
// Parse address and display in all formats.
//
// GET /v2/address/{account_id}/parse
func (s *Server) handleAddressParseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addressParse"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/address/{account_id}/parse"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AddressParse",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddressParse",
			ID:   "addressParse",
		}
	)
	params, err := decodeAddressParseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AddressParseOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddressParse",
			OperationSummary: "",
			OperationID:      "addressParse",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AddressParseParams
			Response = *AddressParseOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAddressParseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddressParse(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddressParse(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeAddressParseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBlockchainAccountInspectRequest handles blockchainAccountInspect operation.
//
// Blockchain account inspect.
//
// GET /v2/blockchain/accounts/{account_id}/inspect
func (s *Server) handleBlockchainAccountInspectRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("blockchainAccountInspect"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/accounts/{account_id}/inspect"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BlockchainAccountInspect",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "BlockchainAccountInspect",
			ID:   "blockchainAccountInspect",
		}
	)
	params, err := decodeBlockchainAccountInspectParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BlockchainAccountInspect
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "BlockchainAccountInspect",
			OperationSummary: "",
			OperationID:      "blockchainAccountInspect",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BlockchainAccountInspectParams
			Response = *BlockchainAccountInspect
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBlockchainAccountInspectParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BlockchainAccountInspect(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BlockchainAccountInspect(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeBlockchainAccountInspectResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDecodeMessageRequest handles decodeMessage operation.
//
// Decode a given message. Only external incoming messages can be decoded currently.
//
// POST /v2/message/decode
func (s *Server) handleDecodeMessageRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("decodeMessage"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/message/decode"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "DecodeMessage",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DecodeMessage",
			ID:   "decodeMessage",
		}
	)
	request, close, err := s.decodeDecodeMessageRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *DecodedMessage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DecodeMessage",
			OperationSummary: "",
			OperationID:      "decodeMessage",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *DecodeMessageReq
			Params   = struct{}
			Response = *DecodedMessage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DecodeMessage(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.DecodeMessage(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeDecodeMessageResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDnsResolveRequest handles dnsResolve operation.
//
// DNS resolve for domain name.
//
// GET /v2/dns/{domain_name}/resolve
func (s *Server) handleDnsResolveRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("dnsResolve"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/dns/{domain_name}/resolve"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "DnsResolve",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DnsResolve",
			ID:   "dnsResolve",
		}
	)
	params, err := decodeDnsResolveParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *DnsRecord
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DnsResolve",
			OperationSummary: "",
			OperationID:      "dnsResolve",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domain_name",
					In:   "path",
				}: params.DomainName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DnsResolveParams
			Response = *DnsRecord
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDnsResolveParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DnsResolve(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DnsResolve(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeDnsResolveResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEmulateMessageToAccountEventRequest handles emulateMessageToAccountEvent operation.
//
// Emulate sending message to blockchain.
//
// POST /v2/accounts/{account_id}/events/emulate
func (s *Server) handleEmulateMessageToAccountEventRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("emulateMessageToAccountEvent"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/events/emulate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EmulateMessageToAccountEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EmulateMessageToAccountEvent",
			ID:   "emulateMessageToAccountEvent",
		}
	)
	params, err := decodeEmulateMessageToAccountEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEmulateMessageToAccountEventRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AccountEvent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "EmulateMessageToAccountEvent",
			OperationSummary: "",
			OperationID:      "emulateMessageToAccountEvent",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "ignore_signature_check",
					In:   "query",
				}: params.IgnoreSignatureCheck,
			},
			Raw: r,
		}

		type (
			Request  = *EmulateMessageToAccountEventReq
			Params   = EmulateMessageToAccountEventParams
			Response = *AccountEvent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEmulateMessageToAccountEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EmulateMessageToAccountEvent(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EmulateMessageToAccountEvent(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeEmulateMessageToAccountEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEmulateMessageToEventRequest handles emulateMessageToEvent operation.
//
// Emulate sending message to blockchain.
//
// POST /v2/events/emulate
func (s *Server) handleEmulateMessageToEventRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("emulateMessageToEvent"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/events/emulate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EmulateMessageToEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EmulateMessageToEvent",
			ID:   "emulateMessageToEvent",
		}
	)
	params, err := decodeEmulateMessageToEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEmulateMessageToEventRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "EmulateMessageToEvent",
			OperationSummary: "",
			OperationID:      "emulateMessageToEvent",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
				{
					Name: "ignore_signature_check",
					In:   "query",
				}: params.IgnoreSignatureCheck,
			},
			Raw: r,
		}

		type (
			Request  = *EmulateMessageToEventReq
			Params   = EmulateMessageToEventParams
			Response = *Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEmulateMessageToEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EmulateMessageToEvent(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EmulateMessageToEvent(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeEmulateMessageToEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEmulateMessageToTraceRequest handles emulateMessageToTrace operation.
//
// Emulate sending message to blockchain.
//
// POST /v2/traces/emulate
func (s *Server) handleEmulateMessageToTraceRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("emulateMessageToTrace"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/traces/emulate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EmulateMessageToTrace",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EmulateMessageToTrace",
			ID:   "emulateMessageToTrace",
		}
	)
	params, err := decodeEmulateMessageToTraceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEmulateMessageToTraceRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Trace
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "EmulateMessageToTrace",
			OperationSummary: "",
			OperationID:      "emulateMessageToTrace",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "ignore_signature_check",
					In:   "query",
				}: params.IgnoreSignatureCheck,
			},
			Raw: r,
		}

		type (
			Request  = *EmulateMessageToTraceReq
			Params   = EmulateMessageToTraceParams
			Response = *Trace
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEmulateMessageToTraceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EmulateMessageToTrace(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EmulateMessageToTrace(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeEmulateMessageToTraceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEmulateMessageToWalletRequest handles emulateMessageToWallet operation.
//
// Emulate sending message to blockchain.
//
// POST /v2/wallet/emulate
func (s *Server) handleEmulateMessageToWalletRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("emulateMessageToWallet"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/wallet/emulate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EmulateMessageToWallet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EmulateMessageToWallet",
			ID:   "emulateMessageToWallet",
		}
	)
	params, err := decodeEmulateMessageToWalletParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEmulateMessageToWalletRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *MessageConsequences
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "EmulateMessageToWallet",
			OperationSummary: "",
			OperationID:      "emulateMessageToWallet",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
			},
			Raw: r,
		}

		type (
			Request  = *EmulateMessageToWalletReq
			Params   = EmulateMessageToWalletParams
			Response = *MessageConsequences
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEmulateMessageToWalletParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EmulateMessageToWallet(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EmulateMessageToWallet(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeEmulateMessageToWalletResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleExecGetMethodForBlockchainAccountRequest handles execGetMethodForBlockchainAccount operation.
//
// Execute get method for account.
//
// GET /v2/blockchain/accounts/{account_id}/methods/{method_name}
func (s *Server) handleExecGetMethodForBlockchainAccountRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("execGetMethodForBlockchainAccount"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/accounts/{account_id}/methods/{method_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ExecGetMethodForBlockchainAccount",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ExecGetMethodForBlockchainAccount",
			ID:   "execGetMethodForBlockchainAccount",
		}
	)
	params, err := decodeExecGetMethodForBlockchainAccountParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *MethodExecutionResult
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ExecGetMethodForBlockchainAccount",
			OperationSummary: "",
			OperationID:      "execGetMethodForBlockchainAccount",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "method_name",
					In:   "path",
				}: params.MethodName,
				{
					Name: "args",
					In:   "query",
				}: params.Args,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ExecGetMethodForBlockchainAccountParams
			Response = *MethodExecutionResult
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackExecGetMethodForBlockchainAccountParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ExecGetMethodForBlockchainAccount(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ExecGetMethodForBlockchainAccount(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeExecGetMethodForBlockchainAccountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGaslessConfigRequest handles gaslessConfig operation.
//
// Returns configuration of gasless transfers.
//
// GET /v2/gasless/config
func (s *Server) handleGaslessConfigRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gaslessConfig"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/gasless/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GaslessConfig",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *GaslessConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GaslessConfig",
			OperationSummary: "",
			OperationID:      "gaslessConfig",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GaslessConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GaslessConfig(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GaslessConfig(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGaslessConfigResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGaslessEstimateRequest handles gaslessEstimate operation.
//
// Estimates the cost of the given messages and returns a payload to sign.
//
// POST /v2/gasless/estimate/{master_id}
func (s *Server) handleGaslessEstimateRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gaslessEstimate"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/gasless/estimate/{master_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GaslessEstimate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GaslessEstimate",
			ID:   "gaslessEstimate",
		}
	)
	params, err := decodeGaslessEstimateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGaslessEstimateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *SignRawParams
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GaslessEstimate",
			OperationSummary: "",
			OperationID:      "gaslessEstimate",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "master_id",
					In:   "path",
				}: params.MasterID,
			},
			Raw: r,
		}

		type (
			Request  = *GaslessEstimateReq
			Params   = GaslessEstimateParams
			Response = *SignRawParams
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGaslessEstimateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GaslessEstimate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GaslessEstimate(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGaslessEstimateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGaslessSendRequest handles gaslessSend operation.
//
// Submits the signed gasless transaction message to the network.
//
// POST /v2/gasless/send
func (s *Server) handleGaslessSendRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gaslessSend"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/gasless/send"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GaslessSend",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GaslessSend",
			ID:   "gaslessSend",
		}
	)
	request, close, err := s.decodeGaslessSendRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *GaslessSendOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GaslessSend",
			OperationSummary: "",
			OperationID:      "gaslessSend",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *GaslessSendReq
			Params   = struct{}
			Response = *GaslessSendOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.GaslessSend(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.GaslessSend(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGaslessSendResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountRequest handles getAccount operation.
//
// Get human-friendly information about an account without low-level details.
//
// GET /v2/accounts/{account_id}
func (s *Server) handleGetAccountRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccount"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccount",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccount",
			ID:   "getAccount",
		}
	)
	params, err := decodeGetAccountParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Account
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccount",
			OperationSummary: "",
			OperationID:      "getAccount",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountParams
			Response = *Account
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccount(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccount(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountDiffRequest handles getAccountDiff operation.
//
// Get account's balance change.
//
// GET /v2/accounts/{account_id}/diff
func (s *Server) handleGetAccountDiffRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountDiff"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/diff"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountDiff",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountDiff",
			ID:   "getAccountDiff",
		}
	)
	params, err := decodeGetAccountDiffParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetAccountDiffOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountDiff",
			OperationSummary: "",
			OperationID:      "getAccountDiff",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "start_date",
					In:   "query",
				}: params.StartDate,
				{
					Name: "end_date",
					In:   "query",
				}: params.EndDate,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountDiffParams
			Response = *GetAccountDiffOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountDiffParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountDiff(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountDiff(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountDiffResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountDnsExpiringRequest handles getAccountDnsExpiring operation.
//
// Get expiring account .ton dns.
//
// GET /v2/accounts/{account_id}/dns/expiring
func (s *Server) handleGetAccountDnsExpiringRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountDnsExpiring"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/dns/expiring"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountDnsExpiring",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountDnsExpiring",
			ID:   "getAccountDnsExpiring",
		}
	)
	params, err := decodeGetAccountDnsExpiringParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *DnsExpiring
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountDnsExpiring",
			OperationSummary: "",
			OperationID:      "getAccountDnsExpiring",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "period",
					In:   "query",
				}: params.Period,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountDnsExpiringParams
			Response = *DnsExpiring
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountDnsExpiringParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountDnsExpiring(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountDnsExpiring(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountDnsExpiringResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountEventRequest handles getAccountEvent operation.
//
// Get event for an account by event_id.
//
// GET /v2/accounts/{account_id}/events/{event_id}
func (s *Server) handleGetAccountEventRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountEvent"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/events/{event_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountEvent",
			ID:   "getAccountEvent",
		}
	)
	params, err := decodeGetAccountEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountEvent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountEvent",
			OperationSummary: "",
			OperationID:      "getAccountEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "event_id",
					In:   "path",
				}: params.EventID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
				{
					Name: "subject_only",
					In:   "query",
				}: params.SubjectOnly,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountEventParams
			Response = *AccountEvent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountEvent(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountEventsRequest handles getAccountEvents operation.
//
// Get events for an account. Each event is built on top of a trace which is a series of transactions
// caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the
// trace into actions, where a single action represents a meaningful high-level operation like a
// Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not
// to build any logic on top of actions because actions can be changed at any time.
//
// GET /v2/accounts/{account_id}/events
func (s *Server) handleGetAccountEventsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountEvents"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountEvents",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountEvents",
			ID:   "getAccountEvents",
		}
	)
	params, err := decodeGetAccountEventsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountEvents
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountEvents",
			OperationSummary: "",
			OperationID:      "getAccountEvents",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
				{
					Name: "initiator",
					In:   "query",
				}: params.Initiator,
				{
					Name: "subject_only",
					In:   "query",
				}: params.SubjectOnly,
				{
					Name: "before_lt",
					In:   "query",
				}: params.BeforeLt,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "start_date",
					In:   "query",
				}: params.StartDate,
				{
					Name: "end_date",
					In:   "query",
				}: params.EndDate,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountEventsParams
			Response = *AccountEvents
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountEventsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountEvents(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountEvents(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountEventsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountInfoByStateInitRequest handles getAccountInfoByStateInit operation.
//
// Get account info by state init.
//
// POST /v2/tonconnect/stateinit
func (s *Server) handleGetAccountInfoByStateInitRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountInfoByStateInit"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/tonconnect/stateinit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountInfoByStateInit",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountInfoByStateInit",
			ID:   "getAccountInfoByStateInit",
		}
	)
	request, close, err := s.decodeGetAccountInfoByStateInitRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AccountInfoByStateInit
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountInfoByStateInit",
			OperationSummary: "",
			OperationID:      "getAccountInfoByStateInit",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *GetAccountInfoByStateInitReq
			Params   = struct{}
			Response = *AccountInfoByStateInit
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountInfoByStateInit(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountInfoByStateInit(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountInfoByStateInitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountInscriptionsRequest handles getAccountInscriptions operation.
//
// Get all inscriptions by owner address. It's experimental API and can be dropped in the future.
//
// GET /v2/experimental/accounts/{account_id}/inscriptions
func (s *Server) handleGetAccountInscriptionsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountInscriptions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/experimental/accounts/{account_id}/inscriptions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountInscriptions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountInscriptions",
			ID:   "getAccountInscriptions",
		}
	)
	params, err := decodeGetAccountInscriptionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *InscriptionBalances
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountInscriptions",
			OperationSummary: "",
			OperationID:      "getAccountInscriptions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountInscriptionsParams
			Response = *InscriptionBalances
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountInscriptionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountInscriptions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountInscriptions(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountInscriptionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountInscriptionsHistoryRequest handles getAccountInscriptionsHistory operation.
//
// Get the transfer inscriptions history for account. It's experimental API and can be dropped in the
// future.
//
// GET /v2/experimental/accounts/{account_id}/inscriptions/history
func (s *Server) handleGetAccountInscriptionsHistoryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountInscriptionsHistory"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/experimental/accounts/{account_id}/inscriptions/history"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountInscriptionsHistory",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountInscriptionsHistory",
			ID:   "getAccountInscriptionsHistory",
		}
	)
	params, err := decodeGetAccountInscriptionsHistoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountEvents
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountInscriptionsHistory",
			OperationSummary: "",
			OperationID:      "getAccountInscriptionsHistory",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
				{
					Name: "before_lt",
					In:   "query",
				}: params.BeforeLt,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountInscriptionsHistoryParams
			Response = *AccountEvents
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountInscriptionsHistoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountInscriptionsHistory(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountInscriptionsHistory(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountInscriptionsHistoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountInscriptionsHistoryByTickerRequest handles getAccountInscriptionsHistoryByTicker operation.
//
// Get the transfer inscriptions history for account. It's experimental API and can be dropped in the
// future.
//
// GET /v2/experimental/accounts/{account_id}/inscriptions/{ticker}/history
func (s *Server) handleGetAccountInscriptionsHistoryByTickerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountInscriptionsHistoryByTicker"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/experimental/accounts/{account_id}/inscriptions/{ticker}/history"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountInscriptionsHistoryByTicker",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountInscriptionsHistoryByTicker",
			ID:   "getAccountInscriptionsHistoryByTicker",
		}
	)
	params, err := decodeGetAccountInscriptionsHistoryByTickerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountEvents
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountInscriptionsHistoryByTicker",
			OperationSummary: "",
			OperationID:      "getAccountInscriptionsHistoryByTicker",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
				{
					Name: "ticker",
					In:   "path",
				}: params.Ticker,
				{
					Name: "before_lt",
					In:   "query",
				}: params.BeforeLt,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountInscriptionsHistoryByTickerParams
			Response = *AccountEvents
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountInscriptionsHistoryByTickerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountInscriptionsHistoryByTicker(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountInscriptionsHistoryByTicker(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountInscriptionsHistoryByTickerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountJettonBalanceRequest handles getAccountJettonBalance operation.
//
// Get Jetton balance by owner address.
//
// GET /v2/accounts/{account_id}/jettons/{jetton_id}
func (s *Server) handleGetAccountJettonBalanceRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountJettonBalance"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/jettons/{jetton_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountJettonBalance",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountJettonBalance",
			ID:   "getAccountJettonBalance",
		}
	)
	params, err := decodeGetAccountJettonBalanceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *JettonBalance
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountJettonBalance",
			OperationSummary: "",
			OperationID:      "getAccountJettonBalance",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "jetton_id",
					In:   "path",
				}: params.JettonID,
				{
					Name: "currencies",
					In:   "query",
				}: params.Currencies,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountJettonBalanceParams
			Response = *JettonBalance
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountJettonBalanceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountJettonBalance(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountJettonBalance(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountJettonBalanceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountJettonHistoryByIDRequest handles getAccountJettonHistoryByID operation.
//
// Get the transfer jetton history for account and jetton.
//
// GET /v2/accounts/{account_id}/jettons/{jetton_id}/history
func (s *Server) handleGetAccountJettonHistoryByIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountJettonHistoryByID"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/jettons/{jetton_id}/history"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountJettonHistoryByID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountJettonHistoryByID",
			ID:   "getAccountJettonHistoryByID",
		}
	)
	params, err := decodeGetAccountJettonHistoryByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountEvents
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountJettonHistoryByID",
			OperationSummary: "",
			OperationID:      "getAccountJettonHistoryByID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "jetton_id",
					In:   "path",
				}: params.JettonID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
				{
					Name: "before_lt",
					In:   "query",
				}: params.BeforeLt,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "start_date",
					In:   "query",
				}: params.StartDate,
				{
					Name: "end_date",
					In:   "query",
				}: params.EndDate,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountJettonHistoryByIDParams
			Response = *AccountEvents
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountJettonHistoryByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountJettonHistoryByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountJettonHistoryByID(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountJettonHistoryByIDResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountJettonsBalancesRequest handles getAccountJettonsBalances operation.
//
// Get all Jettons balances by owner address.
//
// GET /v2/accounts/{account_id}/jettons
func (s *Server) handleGetAccountJettonsBalancesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountJettonsBalances"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/jettons"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountJettonsBalances",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountJettonsBalances",
			ID:   "getAccountJettonsBalances",
		}
	)
	params, err := decodeGetAccountJettonsBalancesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *JettonsBalances
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountJettonsBalances",
			OperationSummary: "",
			OperationID:      "getAccountJettonsBalances",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "currencies",
					In:   "query",
				}: params.Currencies,
				{
					Name: "supported_extensions",
					In:   "query",
				}: params.SupportedExtensions,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountJettonsBalancesParams
			Response = *JettonsBalances
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountJettonsBalancesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountJettonsBalances(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountJettonsBalances(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountJettonsBalancesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountJettonsHistoryRequest handles getAccountJettonsHistory operation.
//
// Get the transfer jettons history for account.
//
// GET /v2/accounts/{account_id}/jettons/history
func (s *Server) handleGetAccountJettonsHistoryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountJettonsHistory"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/jettons/history"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountJettonsHistory",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountJettonsHistory",
			ID:   "getAccountJettonsHistory",
		}
	)
	params, err := decodeGetAccountJettonsHistoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountEvents
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountJettonsHistory",
			OperationSummary: "",
			OperationID:      "getAccountJettonsHistory",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
				{
					Name: "before_lt",
					In:   "query",
				}: params.BeforeLt,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "start_date",
					In:   "query",
				}: params.StartDate,
				{
					Name: "end_date",
					In:   "query",
				}: params.EndDate,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountJettonsHistoryParams
			Response = *AccountEvents
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountJettonsHistoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountJettonsHistory(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountJettonsHistory(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountJettonsHistoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountMultisigsRequest handles getAccountMultisigs operation.
//
// Get account's multisigs.
//
// GET /v2/accounts/{account_id}/multisigs
func (s *Server) handleGetAccountMultisigsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountMultisigs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/multisigs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountMultisigs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountMultisigs",
			ID:   "getAccountMultisigs",
		}
	)
	params, err := decodeGetAccountMultisigsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Multisigs
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountMultisigs",
			OperationSummary: "",
			OperationID:      "getAccountMultisigs",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountMultisigsParams
			Response = *Multisigs
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountMultisigsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountMultisigs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountMultisigs(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountMultisigsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountNftHistoryRequest handles getAccountNftHistory operation.
//
// Get the transfer nft history.
//
// GET /v2/accounts/{account_id}/nfts/history
func (s *Server) handleGetAccountNftHistoryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountNftHistory"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/nfts/history"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountNftHistory",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountNftHistory",
			ID:   "getAccountNftHistory",
		}
	)
	params, err := decodeGetAccountNftHistoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountEvents
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountNftHistory",
			OperationSummary: "",
			OperationID:      "getAccountNftHistory",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
				{
					Name: "before_lt",
					In:   "query",
				}: params.BeforeLt,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "start_date",
					In:   "query",
				}: params.StartDate,
				{
					Name: "end_date",
					In:   "query",
				}: params.EndDate,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountNftHistoryParams
			Response = *AccountEvents
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountNftHistoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountNftHistory(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountNftHistory(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountNftHistoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountNftItemsRequest handles getAccountNftItems operation.
//
// Get all NFT items by owner address.
//
// GET /v2/accounts/{account_id}/nfts
func (s *Server) handleGetAccountNftItemsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountNftItems"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/nfts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountNftItems",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountNftItems",
			ID:   "getAccountNftItems",
		}
	)
	params, err := decodeGetAccountNftItemsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *NftItems
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountNftItems",
			OperationSummary: "",
			OperationID:      "getAccountNftItems",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "collection",
					In:   "query",
				}: params.Collection,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
				{
					Name: "indirect_ownership",
					In:   "query",
				}: params.IndirectOwnership,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountNftItemsParams
			Response = *NftItems
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountNftItemsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountNftItems(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountNftItems(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountNftItemsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountNominatorsPoolsRequest handles getAccountNominatorsPools operation.
//
// All pools where account participates.
//
// GET /v2/staking/nominator/{account_id}/pools
func (s *Server) handleGetAccountNominatorsPoolsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountNominatorsPools"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/staking/nominator/{account_id}/pools"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountNominatorsPools",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountNominatorsPools",
			ID:   "getAccountNominatorsPools",
		}
	)
	params, err := decodeGetAccountNominatorsPoolsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountStaking
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountNominatorsPools",
			OperationSummary: "",
			OperationID:      "getAccountNominatorsPools",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountNominatorsPoolsParams
			Response = *AccountStaking
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountNominatorsPoolsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountNominatorsPools(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountNominatorsPools(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountNominatorsPoolsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountPublicKeyRequest handles getAccountPublicKey operation.
//
// Get public key by account id.
//
// GET /v2/accounts/{account_id}/publickey
func (s *Server) handleGetAccountPublicKeyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountPublicKey"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/publickey"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountPublicKey",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountPublicKey",
			ID:   "getAccountPublicKey",
		}
	)
	params, err := decodeGetAccountPublicKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetAccountPublicKeyOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountPublicKey",
			OperationSummary: "",
			OperationID:      "getAccountPublicKey",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountPublicKeyParams
			Response = *GetAccountPublicKeyOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountPublicKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountPublicKey(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountPublicKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountSeqnoRequest handles getAccountSeqno operation.
//
// Get account seqno.
//
// GET /v2/wallet/{account_id}/seqno
func (s *Server) handleGetAccountSeqnoRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountSeqno"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/wallet/{account_id}/seqno"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountSeqno",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountSeqno",
			ID:   "getAccountSeqno",
		}
	)
	params, err := decodeGetAccountSeqnoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Seqno
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountSeqno",
			OperationSummary: "",
			OperationID:      "getAccountSeqno",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountSeqnoParams
			Response = *Seqno
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountSeqnoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountSeqno(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountSeqno(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountSeqnoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountSubscriptionsRequest handles getAccountSubscriptions operation.
//
// Get all subscriptions by wallet address.
//
// GET /v2/accounts/{account_id}/subscriptions
func (s *Server) handleGetAccountSubscriptionsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountSubscriptions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/subscriptions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountSubscriptions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountSubscriptions",
			ID:   "getAccountSubscriptions",
		}
	)
	params, err := decodeGetAccountSubscriptionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Subscriptions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountSubscriptions",
			OperationSummary: "",
			OperationID:      "getAccountSubscriptions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountSubscriptionsParams
			Response = *Subscriptions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountSubscriptionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountSubscriptions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountSubscriptions(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountSubscriptionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountTracesRequest handles getAccountTraces operation.
//
// Get traces for account.
//
// GET /v2/accounts/{account_id}/traces
func (s *Server) handleGetAccountTracesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccountTraces"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/traces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccountTraces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccountTraces",
			ID:   "getAccountTraces",
		}
	)
	params, err := decodeGetAccountTracesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TraceIDs
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccountTraces",
			OperationSummary: "",
			OperationID:      "getAccountTraces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "before_lt",
					In:   "query",
				}: params.BeforeLt,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAccountTracesParams
			Response = *TraceIDs
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountTracesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccountTraces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccountTraces(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountTracesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAccountsRequest handles getAccounts operation.
//
// Get human-friendly information about several accounts without low-level details.
//
// POST /v2/accounts/_bulk
func (s *Server) handleGetAccountsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAccounts"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/accounts/_bulk"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAccounts",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAccounts",
			ID:   "getAccounts",
		}
	)
	params, err := decodeGetAccountsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGetAccountsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Accounts
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAccounts",
			OperationSummary: "",
			OperationID:      "getAccounts",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "currency",
					In:   "query",
				}: params.Currency,
			},
			Raw: r,
		}

		type (
			Request  = OptGetAccountsReq
			Params   = GetAccountsParams
			Response = *Accounts
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAccountsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAccounts(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAccounts(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAccountsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAllAuctionsRequest handles getAllAuctions operation.
//
// Get all auctions.
//
// GET /v2/dns/auctions
func (s *Server) handleGetAllAuctionsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAllAuctions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/dns/auctions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAllAuctions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAllAuctions",
			ID:   "getAllAuctions",
		}
	)
	params, err := decodeGetAllAuctionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Auctions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAllAuctions",
			OperationSummary: "",
			OperationID:      "getAllAuctions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "tld",
					In:   "query",
				}: params.Tld,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAllAuctionsParams
			Response = *Auctions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAllAuctionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAllAuctions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAllAuctions(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAllAuctionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAllRawShardsInfoRequest handles getAllRawShardsInfo operation.
//
// Get all raw shards info.
//
// GET /v2/liteserver/get_all_shards_info/{block_id}
func (s *Server) handleGetAllRawShardsInfoRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAllRawShardsInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_all_shards_info/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAllRawShardsInfo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAllRawShardsInfo",
			ID:   "getAllRawShardsInfo",
		}
	)
	params, err := decodeGetAllRawShardsInfoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetAllRawShardsInfoOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAllRawShardsInfo",
			OperationSummary: "",
			OperationID:      "getAllRawShardsInfo",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAllRawShardsInfoParams
			Response = *GetAllRawShardsInfoOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAllRawShardsInfoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAllRawShardsInfo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAllRawShardsInfo(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAllRawShardsInfoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainAccountTransactionsRequest handles getBlockchainAccountTransactions operation.
//
// Get account transactions.
//
// GET /v2/blockchain/accounts/{account_id}/transactions
func (s *Server) handleGetBlockchainAccountTransactionsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainAccountTransactions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/accounts/{account_id}/transactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainAccountTransactions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockchainAccountTransactions",
			ID:   "getBlockchainAccountTransactions",
		}
	)
	params, err := decodeGetBlockchainAccountTransactionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Transactions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainAccountTransactions",
			OperationSummary: "",
			OperationID:      "getBlockchainAccountTransactions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "after_lt",
					In:   "query",
				}: params.AfterLt,
				{
					Name: "before_lt",
					In:   "query",
				}: params.BeforeLt,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "sort_order",
					In:   "query",
				}: params.SortOrder,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockchainAccountTransactionsParams
			Response = *Transactions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockchainAccountTransactionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainAccountTransactions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainAccountTransactions(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainAccountTransactionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainBlockRequest handles getBlockchainBlock operation.
//
// Get blockchain block data.
//
// GET /v2/blockchain/blocks/{block_id}
func (s *Server) handleGetBlockchainBlockRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainBlock"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/blocks/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainBlock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockchainBlock",
			ID:   "getBlockchainBlock",
		}
	)
	params, err := decodeGetBlockchainBlockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BlockchainBlock
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainBlock",
			OperationSummary: "",
			OperationID:      "getBlockchainBlock",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockchainBlockParams
			Response = *BlockchainBlock
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockchainBlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainBlock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainBlock(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainBlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainBlockTransactionsRequest handles getBlockchainBlockTransactions operation.
//
// Get transactions from block.
//
// GET /v2/blockchain/blocks/{block_id}/transactions
func (s *Server) handleGetBlockchainBlockTransactionsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainBlockTransactions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/blocks/{block_id}/transactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainBlockTransactions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockchainBlockTransactions",
			ID:   "getBlockchainBlockTransactions",
		}
	)
	params, err := decodeGetBlockchainBlockTransactionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Transactions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainBlockTransactions",
			OperationSummary: "",
			OperationID:      "getBlockchainBlockTransactions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockchainBlockTransactionsParams
			Response = *Transactions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockchainBlockTransactionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainBlockTransactions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainBlockTransactions(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainBlockTransactionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainConfigRequest handles getBlockchainConfig operation.
//
// Get blockchain config.
//
// GET /v2/blockchain/config
func (s *Server) handleGetBlockchainConfigRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainConfig"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainConfig",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *BlockchainConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainConfig",
			OperationSummary: "",
			OperationID:      "getBlockchainConfig",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *BlockchainConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainConfig(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainConfig(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainConfigResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainConfigFromBlockRequest handles getBlockchainConfigFromBlock operation.
//
// Get blockchain config from a specific block, if present.
//
// GET /v2/blockchain/masterchain/{masterchain_seqno}/config
func (s *Server) handleGetBlockchainConfigFromBlockRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainConfigFromBlock"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/masterchain/{masterchain_seqno}/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainConfigFromBlock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockchainConfigFromBlock",
			ID:   "getBlockchainConfigFromBlock",
		}
	)
	params, err := decodeGetBlockchainConfigFromBlockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BlockchainConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainConfigFromBlock",
			OperationSummary: "",
			OperationID:      "getBlockchainConfigFromBlock",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "masterchain_seqno",
					In:   "path",
				}: params.MasterchainSeqno,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockchainConfigFromBlockParams
			Response = *BlockchainConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockchainConfigFromBlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainConfigFromBlock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainConfigFromBlock(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainConfigFromBlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainMasterchainBlocksRequest handles getBlockchainMasterchainBlocks operation.
//
// Get all blocks in all shards and workchains between target and previous masterchain block
// according to shards last blocks snapshot in masterchain.  We don't recommend to build your app
// around this method because it has problem with scalability and will work very slow in the future.
//
// GET /v2/blockchain/masterchain/{masterchain_seqno}/blocks
func (s *Server) handleGetBlockchainMasterchainBlocksRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainMasterchainBlocks"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/masterchain/{masterchain_seqno}/blocks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainMasterchainBlocks",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockchainMasterchainBlocks",
			ID:   "getBlockchainMasterchainBlocks",
		}
	)
	params, err := decodeGetBlockchainMasterchainBlocksParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BlockchainBlocks
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainMasterchainBlocks",
			OperationSummary: "",
			OperationID:      "getBlockchainMasterchainBlocks",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "masterchain_seqno",
					In:   "path",
				}: params.MasterchainSeqno,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockchainMasterchainBlocksParams
			Response = *BlockchainBlocks
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockchainMasterchainBlocksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainMasterchainBlocks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainMasterchainBlocks(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainMasterchainBlocksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainMasterchainHeadRequest handles getBlockchainMasterchainHead operation.
//
// Get last known masterchain block.
//
// GET /v2/blockchain/masterchain-head
func (s *Server) handleGetBlockchainMasterchainHeadRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainMasterchainHead"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/masterchain-head"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainMasterchainHead",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *BlockchainBlock
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainMasterchainHead",
			OperationSummary: "",
			OperationID:      "getBlockchainMasterchainHead",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *BlockchainBlock
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainMasterchainHead(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainMasterchainHead(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainMasterchainHeadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainMasterchainShardsRequest handles getBlockchainMasterchainShards operation.
//
// Get blockchain block shards.
//
// GET /v2/blockchain/masterchain/{masterchain_seqno}/shards
func (s *Server) handleGetBlockchainMasterchainShardsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainMasterchainShards"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/masterchain/{masterchain_seqno}/shards"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainMasterchainShards",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockchainMasterchainShards",
			ID:   "getBlockchainMasterchainShards",
		}
	)
	params, err := decodeGetBlockchainMasterchainShardsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BlockchainBlockShards
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainMasterchainShards",
			OperationSummary: "",
			OperationID:      "getBlockchainMasterchainShards",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "masterchain_seqno",
					In:   "path",
				}: params.MasterchainSeqno,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockchainMasterchainShardsParams
			Response = *BlockchainBlockShards
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockchainMasterchainShardsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainMasterchainShards(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainMasterchainShards(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainMasterchainShardsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainMasterchainTransactionsRequest handles getBlockchainMasterchainTransactions operation.
//
// Get all transactions in all shards and workchains between target and previous masterchain block
// according to shards last blocks snapshot in masterchain. We don't recommend to build your app
// around this method because it has problem with scalability and will work very slow in the future.
//
// GET /v2/blockchain/masterchain/{masterchain_seqno}/transactions
func (s *Server) handleGetBlockchainMasterchainTransactionsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainMasterchainTransactions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/masterchain/{masterchain_seqno}/transactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainMasterchainTransactions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockchainMasterchainTransactions",
			ID:   "getBlockchainMasterchainTransactions",
		}
	)
	params, err := decodeGetBlockchainMasterchainTransactionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Transactions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainMasterchainTransactions",
			OperationSummary: "",
			OperationID:      "getBlockchainMasterchainTransactions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "masterchain_seqno",
					In:   "path",
				}: params.MasterchainSeqno,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockchainMasterchainTransactionsParams
			Response = *Transactions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockchainMasterchainTransactionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainMasterchainTransactions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainMasterchainTransactions(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainMasterchainTransactionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainRawAccountRequest handles getBlockchainRawAccount operation.
//
// Get low-level information about an account taken directly from the blockchain.
//
// GET /v2/blockchain/accounts/{account_id}
func (s *Server) handleGetBlockchainRawAccountRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainRawAccount"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/accounts/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainRawAccount",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockchainRawAccount",
			ID:   "getBlockchainRawAccount",
		}
	)
	params, err := decodeGetBlockchainRawAccountParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BlockchainRawAccount
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainRawAccount",
			OperationSummary: "",
			OperationID:      "getBlockchainRawAccount",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockchainRawAccountParams
			Response = *BlockchainRawAccount
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockchainRawAccountParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainRawAccount(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainRawAccount(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainRawAccountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainTransactionRequest handles getBlockchainTransaction operation.
//
// Get transaction data.
//
// GET /v2/blockchain/transactions/{transaction_id}
func (s *Server) handleGetBlockchainTransactionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainTransaction"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/transactions/{transaction_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainTransaction",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockchainTransaction",
			ID:   "getBlockchainTransaction",
		}
	)
	params, err := decodeGetBlockchainTransactionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Transaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainTransaction",
			OperationSummary: "",
			OperationID:      "getBlockchainTransaction",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "transaction_id",
					In:   "path",
				}: params.TransactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockchainTransactionParams
			Response = *Transaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockchainTransactionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainTransaction(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainTransaction(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainTransactionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainTransactionByMessageHashRequest handles getBlockchainTransactionByMessageHash operation.
//
// Get transaction data by message hash.
//
// GET /v2/blockchain/messages/{msg_id}/transaction
func (s *Server) handleGetBlockchainTransactionByMessageHashRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainTransactionByMessageHash"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/messages/{msg_id}/transaction"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainTransactionByMessageHash",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockchainTransactionByMessageHash",
			ID:   "getBlockchainTransactionByMessageHash",
		}
	)
	params, err := decodeGetBlockchainTransactionByMessageHashParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Transaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainTransactionByMessageHash",
			OperationSummary: "",
			OperationID:      "getBlockchainTransactionByMessageHash",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "msg_id",
					In:   "path",
				}: params.MsgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockchainTransactionByMessageHashParams
			Response = *Transaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockchainTransactionByMessageHashParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainTransactionByMessageHash(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainTransactionByMessageHash(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainTransactionByMessageHashResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockchainValidatorsRequest handles getBlockchainValidators operation.
//
// Get blockchain validators.
//
// GET /v2/blockchain/validators
func (s *Server) handleGetBlockchainValidatorsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockchainValidators"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/validators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockchainValidators",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *Validators
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockchainValidators",
			OperationSummary: "",
			OperationID:      "getBlockchainValidators",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *Validators
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockchainValidators(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockchainValidators(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetBlockchainValidatorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetChartRatesRequest handles getChartRates operation.
//
// Get chart by token.
//
// GET /v2/rates/chart
func (s *Server) handleGetChartRatesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChartRates"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/rates/chart"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetChartRates",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetChartRates",
			ID:   "getChartRates",
		}
	)
	params, err := decodeGetChartRatesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetChartRatesOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetChartRates",
			OperationSummary: "",
			OperationID:      "getChartRates",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "token",
					In:   "query",
				}: params.Token,
				{
					Name: "currency",
					In:   "query",
				}: params.Currency,
				{
					Name: "start_date",
					In:   "query",
				}: params.StartDate,
				{
					Name: "end_date",
					In:   "query",
				}: params.EndDate,
				{
					Name: "points_count",
					In:   "query",
				}: params.PointsCount,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetChartRatesParams
			Response = *GetChartRatesOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetChartRatesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetChartRates(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetChartRates(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetChartRatesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDnsInfoRequest handles getDnsInfo operation.
//
// Get full information about domain name.
//
// GET /v2/dns/{domain_name}
func (s *Server) handleGetDnsInfoRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDnsInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/dns/{domain_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDnsInfo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDnsInfo",
			ID:   "getDnsInfo",
		}
	)
	params, err := decodeGetDnsInfoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *DomainInfo
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDnsInfo",
			OperationSummary: "",
			OperationID:      "getDnsInfo",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domain_name",
					In:   "path",
				}: params.DomainName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDnsInfoParams
			Response = *DomainInfo
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDnsInfoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDnsInfo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDnsInfo(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetDnsInfoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDomainBidsRequest handles getDomainBids operation.
//
// Get domain bids.
//
// GET /v2/dns/{domain_name}/bids
func (s *Server) handleGetDomainBidsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDomainBids"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/dns/{domain_name}/bids"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDomainBids",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDomainBids",
			ID:   "getDomainBids",
		}
	)
	params, err := decodeGetDomainBidsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *DomainBids
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDomainBids",
			OperationSummary: "",
			OperationID:      "getDomainBids",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domain_name",
					In:   "path",
				}: params.DomainName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDomainBidsParams
			Response = *DomainBids
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDomainBidsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDomainBids(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDomainBids(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetDomainBidsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEventRequest handles getEvent operation.
//
// Get an event either by event ID or a hash of any transaction in a trace. An event is built on top
// of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known
// patterns inside the trace and splits the trace into actions, where a single action represents a
// meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to
// be shown to users. It is advised not to build any logic on top of actions because actions can be
// changed at any time.
//
// GET /v2/events/{event_id}
func (s *Server) handleGetEventRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEvent"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/events/{event_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEvent",
			ID:   "getEvent",
		}
	)
	params, err := decodeGetEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEvent",
			OperationSummary: "",
			OperationID:      "getEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "event_id",
					In:   "path",
				}: params.EventID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEventParams
			Response = *Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEvent(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetInscriptionOpTemplateRequest handles getInscriptionOpTemplate operation.
//
// Return comment for making operation with inscription. please don't use it if you don't know what
// you are doing.
//
// GET /v2/experimental/inscriptions/op-template
func (s *Server) handleGetInscriptionOpTemplateRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getInscriptionOpTemplate"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/experimental/inscriptions/op-template"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetInscriptionOpTemplate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetInscriptionOpTemplate",
			ID:   "getInscriptionOpTemplate",
		}
	)
	params, err := decodeGetInscriptionOpTemplateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetInscriptionOpTemplateOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetInscriptionOpTemplate",
			OperationSummary: "",
			OperationID:      "getInscriptionOpTemplate",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "type",
					In:   "query",
				}: params.Type,
				{
					Name: "destination",
					In:   "query",
				}: params.Destination,
				{
					Name: "comment",
					In:   "query",
				}: params.Comment,
				{
					Name: "operation",
					In:   "query",
				}: params.Operation,
				{
					Name: "amount",
					In:   "query",
				}: params.Amount,
				{
					Name: "ticker",
					In:   "query",
				}: params.Ticker,
				{
					Name: "who",
					In:   "query",
				}: params.Who,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetInscriptionOpTemplateParams
			Response = *GetInscriptionOpTemplateOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetInscriptionOpTemplateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetInscriptionOpTemplate(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetInscriptionOpTemplate(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetInscriptionOpTemplateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetItemsFromCollectionRequest handles getItemsFromCollection operation.
//
// Get NFT items from collection by collection address.
//
// GET /v2/nfts/collections/{account_id}/items
func (s *Server) handleGetItemsFromCollectionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getItemsFromCollection"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/nfts/collections/{account_id}/items"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetItemsFromCollection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetItemsFromCollection",
			ID:   "getItemsFromCollection",
		}
	)
	params, err := decodeGetItemsFromCollectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *NftItems
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetItemsFromCollection",
			OperationSummary: "",
			OperationID:      "getItemsFromCollection",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetItemsFromCollectionParams
			Response = *NftItems
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetItemsFromCollectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetItemsFromCollection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetItemsFromCollection(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetItemsFromCollectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetJettonHoldersRequest handles getJettonHolders operation.
//
// Get jetton's holders.
//
// GET /v2/jettons/{account_id}/holders
func (s *Server) handleGetJettonHoldersRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getJettonHolders"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/jettons/{account_id}/holders"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetJettonHolders",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetJettonHolders",
			ID:   "getJettonHolders",
		}
	)
	params, err := decodeGetJettonHoldersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *JettonHolders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetJettonHolders",
			OperationSummary: "",
			OperationID:      "getJettonHolders",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetJettonHoldersParams
			Response = *JettonHolders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetJettonHoldersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetJettonHolders(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetJettonHolders(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetJettonHoldersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetJettonInfoRequest handles getJettonInfo operation.
//
// Get jetton metadata by jetton master address.
//
// GET /v2/jettons/{account_id}
func (s *Server) handleGetJettonInfoRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getJettonInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/jettons/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetJettonInfo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetJettonInfo",
			ID:   "getJettonInfo",
		}
	)
	params, err := decodeGetJettonInfoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *JettonInfo
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetJettonInfo",
			OperationSummary: "",
			OperationID:      "getJettonInfo",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetJettonInfoParams
			Response = *JettonInfo
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetJettonInfoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetJettonInfo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetJettonInfo(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetJettonInfoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetJettonTransferPayloadRequest handles getJettonTransferPayload operation.
//
// Get jetton's custom payload and state init required for transfer.
//
// GET /v2/jettons/{jetton_id}/transfer/{account_id}/payload
func (s *Server) handleGetJettonTransferPayloadRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getJettonTransferPayload"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/jettons/{jetton_id}/transfer/{account_id}/payload"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetJettonTransferPayload",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetJettonTransferPayload",
			ID:   "getJettonTransferPayload",
		}
	)
	params, err := decodeGetJettonTransferPayloadParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *JettonTransferPayload
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetJettonTransferPayload",
			OperationSummary: "",
			OperationID:      "getJettonTransferPayload",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "jetton_id",
					In:   "path",
				}: params.JettonID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetJettonTransferPayloadParams
			Response = *JettonTransferPayload
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetJettonTransferPayloadParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetJettonTransferPayload(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetJettonTransferPayload(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetJettonTransferPayloadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetJettonsRequest handles getJettons operation.
//
// Get a list of all indexed jetton masters in the blockchain.
//
// GET /v2/jettons
func (s *Server) handleGetJettonsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getJettons"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/jettons"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetJettons",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetJettons",
			ID:   "getJettons",
		}
	)
	params, err := decodeGetJettonsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Jettons
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetJettons",
			OperationSummary: "",
			OperationID:      "getJettons",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetJettonsParams
			Response = *Jettons
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetJettonsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetJettons(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetJettons(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetJettonsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetJettonsEventsRequest handles getJettonsEvents operation.
//
// Get only jetton transfers in the event.
//
// GET /v2/events/{event_id}/jettons
func (s *Server) handleGetJettonsEventsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getJettonsEvents"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/events/{event_id}/jettons"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetJettonsEvents",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetJettonsEvents",
			ID:   "getJettonsEvents",
		}
	)
	params, err := decodeGetJettonsEventsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetJettonsEvents",
			OperationSummary: "",
			OperationID:      "getJettonsEvents",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "event_id",
					In:   "path",
				}: params.EventID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetJettonsEventsParams
			Response = *Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetJettonsEventsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetJettonsEvents(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetJettonsEvents(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetJettonsEventsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetMarketsRatesRequest handles getMarketsRates operation.
//
// Get the TON price from markets.
//
// GET /v2/rates/markets
func (s *Server) handleGetMarketsRatesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMarketsRates"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/rates/markets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetMarketsRates",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *GetMarketsRatesOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetMarketsRates",
			OperationSummary: "",
			OperationID:      "getMarketsRates",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetMarketsRatesOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetMarketsRates(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetMarketsRates(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetMarketsRatesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetMultisigAccountRequest handles getMultisigAccount operation.
//
// Get multisig account info.
//
// GET /v2/multisig/{account_id}
func (s *Server) handleGetMultisigAccountRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMultisigAccount"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/multisig/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetMultisigAccount",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetMultisigAccount",
			ID:   "getMultisigAccount",
		}
	)
	params, err := decodeGetMultisigAccountParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Multisig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetMultisigAccount",
			OperationSummary: "",
			OperationID:      "getMultisigAccount",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetMultisigAccountParams
			Response = *Multisig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetMultisigAccountParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetMultisigAccount(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetMultisigAccount(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetMultisigAccountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNftCollectionRequest handles getNftCollection operation.
//
// Get NFT collection by collection address.
//
// GET /v2/nfts/collections/{account_id}
func (s *Server) handleGetNftCollectionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNftCollection"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/nfts/collections/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNftCollection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNftCollection",
			ID:   "getNftCollection",
		}
	)
	params, err := decodeGetNftCollectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *NftCollection
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNftCollection",
			OperationSummary: "",
			OperationID:      "getNftCollection",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNftCollectionParams
			Response = *NftCollection
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNftCollectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNftCollection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNftCollection(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetNftCollectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNftCollectionsRequest handles getNftCollections operation.
//
// Get NFT collections.
//
// GET /v2/nfts/collections
func (s *Server) handleGetNftCollectionsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNftCollections"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/nfts/collections"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNftCollections",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNftCollections",
			ID:   "getNftCollections",
		}
	)
	params, err := decodeGetNftCollectionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *NftCollections
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNftCollections",
			OperationSummary: "",
			OperationID:      "getNftCollections",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNftCollectionsParams
			Response = *NftCollections
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNftCollectionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNftCollections(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNftCollections(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetNftCollectionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNftHistoryByIDRequest handles getNftHistoryByID operation.
//
// Get the transfer nfts history for account.
//
// GET /v2/nfts/{account_id}/history
func (s *Server) handleGetNftHistoryByIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNftHistoryByID"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/nfts/{account_id}/history"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNftHistoryByID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNftHistoryByID",
			ID:   "getNftHistoryByID",
		}
	)
	params, err := decodeGetNftHistoryByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountEvents
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNftHistoryByID",
			OperationSummary: "",
			OperationID:      "getNftHistoryByID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
				{
					Name: "before_lt",
					In:   "query",
				}: params.BeforeLt,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "start_date",
					In:   "query",
				}: params.StartDate,
				{
					Name: "end_date",
					In:   "query",
				}: params.EndDate,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNftHistoryByIDParams
			Response = *AccountEvents
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNftHistoryByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNftHistoryByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNftHistoryByID(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetNftHistoryByIDResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNftItemByAddressRequest handles getNftItemByAddress operation.
//
// Get NFT item by its address.
//
// GET /v2/nfts/{account_id}
func (s *Server) handleGetNftItemByAddressRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNftItemByAddress"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/nfts/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNftItemByAddress",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNftItemByAddress",
			ID:   "getNftItemByAddress",
		}
	)
	params, err := decodeGetNftItemByAddressParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *NftItem
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNftItemByAddress",
			OperationSummary: "",
			OperationID:      "getNftItemByAddress",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNftItemByAddressParams
			Response = *NftItem
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNftItemByAddressParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNftItemByAddress(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNftItemByAddress(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetNftItemByAddressResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNftItemsByAddressesRequest handles getNftItemsByAddresses operation.
//
// Get NFT items by their addresses.
//
// POST /v2/nfts/_bulk
func (s *Server) handleGetNftItemsByAddressesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNftItemsByAddresses"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/nfts/_bulk"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNftItemsByAddresses",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNftItemsByAddresses",
			ID:   "getNftItemsByAddresses",
		}
	)
	request, close, err := s.decodeGetNftItemsByAddressesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *NftItems
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNftItemsByAddresses",
			OperationSummary: "",
			OperationID:      "getNftItemsByAddresses",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = OptGetNftItemsByAddressesReq
			Params   = struct{}
			Response = *NftItems
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNftItemsByAddresses(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNftItemsByAddresses(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetNftItemsByAddressesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetOutMsgQueueSizesRequest handles getOutMsgQueueSizes operation.
//
// Get out msg queue sizes.
//
// GET /v2/liteserver/get_out_msg_queue_sizes
func (s *Server) handleGetOutMsgQueueSizesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOutMsgQueueSizes"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_out_msg_queue_sizes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetOutMsgQueueSizes",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *GetOutMsgQueueSizesOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetOutMsgQueueSizes",
			OperationSummary: "",
			OperationID:      "getOutMsgQueueSizes",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetOutMsgQueueSizesOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetOutMsgQueueSizes(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetOutMsgQueueSizes(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetOutMsgQueueSizesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRatesRequest handles getRates operation.
//
// Get the token price in the chosen currency for display only. Dont use this for financial
// transactions.
//
// GET /v2/rates
func (s *Server) handleGetRatesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRates"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/rates"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRates",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRates",
			ID:   "getRates",
		}
	)
	params, err := decodeGetRatesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRatesOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRates",
			OperationSummary: "",
			OperationID:      "getRates",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "tokens",
					In:   "query",
				}: params.Tokens,
				{
					Name: "currencies",
					In:   "query",
				}: params.Currencies,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRatesParams
			Response = *GetRatesOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRatesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRates(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRates(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRatesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawAccountStateRequest handles getRawAccountState operation.
//
// Get raw account state.
//
// GET /v2/liteserver/get_account_state/{account_id}
func (s *Server) handleGetRawAccountStateRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawAccountState"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_account_state/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawAccountState",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawAccountState",
			ID:   "getRawAccountState",
		}
	)
	params, err := decodeGetRawAccountStateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawAccountStateOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawAccountState",
			OperationSummary: "",
			OperationID:      "getRawAccountState",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "target_block",
					In:   "query",
				}: params.TargetBlock,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawAccountStateParams
			Response = *GetRawAccountStateOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawAccountStateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawAccountState(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawAccountState(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawAccountStateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawBlockProofRequest handles getRawBlockProof operation.
//
// Get raw block proof.
//
// GET /v2/liteserver/get_block_proof
func (s *Server) handleGetRawBlockProofRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawBlockProof"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_block_proof"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawBlockProof",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawBlockProof",
			ID:   "getRawBlockProof",
		}
	)
	params, err := decodeGetRawBlockProofParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawBlockProofOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawBlockProof",
			OperationSummary: "",
			OperationID:      "getRawBlockProof",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "known_block",
					In:   "query",
				}: params.KnownBlock,
				{
					Name: "target_block",
					In:   "query",
				}: params.TargetBlock,
				{
					Name: "mode",
					In:   "query",
				}: params.Mode,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawBlockProofParams
			Response = *GetRawBlockProofOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawBlockProofParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawBlockProof(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawBlockProof(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawBlockProofResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawBlockchainBlockRequest handles getRawBlockchainBlock operation.
//
// Get raw blockchain block.
//
// GET /v2/liteserver/get_block/{block_id}
func (s *Server) handleGetRawBlockchainBlockRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawBlockchainBlock"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_block/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawBlockchainBlock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawBlockchainBlock",
			ID:   "getRawBlockchainBlock",
		}
	)
	params, err := decodeGetRawBlockchainBlockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawBlockchainBlockOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawBlockchainBlock",
			OperationSummary: "",
			OperationID:      "getRawBlockchainBlock",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawBlockchainBlockParams
			Response = *GetRawBlockchainBlockOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawBlockchainBlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawBlockchainBlock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawBlockchainBlock(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawBlockchainBlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawBlockchainBlockHeaderRequest handles getRawBlockchainBlockHeader operation.
//
// Get raw blockchain block header.
//
// GET /v2/liteserver/get_block_header/{block_id}
func (s *Server) handleGetRawBlockchainBlockHeaderRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawBlockchainBlockHeader"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_block_header/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawBlockchainBlockHeader",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawBlockchainBlockHeader",
			ID:   "getRawBlockchainBlockHeader",
		}
	)
	params, err := decodeGetRawBlockchainBlockHeaderParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawBlockchainBlockHeaderOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawBlockchainBlockHeader",
			OperationSummary: "",
			OperationID:      "getRawBlockchainBlockHeader",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
				{
					Name: "mode",
					In:   "query",
				}: params.Mode,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawBlockchainBlockHeaderParams
			Response = *GetRawBlockchainBlockHeaderOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawBlockchainBlockHeaderParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawBlockchainBlockHeader(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawBlockchainBlockHeader(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawBlockchainBlockHeaderResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawBlockchainBlockStateRequest handles getRawBlockchainBlockState operation.
//
// Get raw blockchain block state.
//
// GET /v2/liteserver/get_state/{block_id}
func (s *Server) handleGetRawBlockchainBlockStateRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawBlockchainBlockState"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_state/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawBlockchainBlockState",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawBlockchainBlockState",
			ID:   "getRawBlockchainBlockState",
		}
	)
	params, err := decodeGetRawBlockchainBlockStateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawBlockchainBlockStateOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawBlockchainBlockState",
			OperationSummary: "",
			OperationID:      "getRawBlockchainBlockState",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawBlockchainBlockStateParams
			Response = *GetRawBlockchainBlockStateOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawBlockchainBlockStateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawBlockchainBlockState(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawBlockchainBlockState(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawBlockchainBlockStateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawBlockchainConfigRequest handles getRawBlockchainConfig operation.
//
// Get raw blockchain config.
//
// GET /v2/blockchain/config/raw
func (s *Server) handleGetRawBlockchainConfigRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawBlockchainConfig"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/config/raw"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawBlockchainConfig",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *RawBlockchainConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawBlockchainConfig",
			OperationSummary: "",
			OperationID:      "getRawBlockchainConfig",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *RawBlockchainConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawBlockchainConfig(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawBlockchainConfig(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawBlockchainConfigResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawBlockchainConfigFromBlockRequest handles getRawBlockchainConfigFromBlock operation.
//
// Get raw blockchain config from a specific block, if present.
//
// GET /v2/blockchain/masterchain/{masterchain_seqno}/config/raw
func (s *Server) handleGetRawBlockchainConfigFromBlockRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawBlockchainConfigFromBlock"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/masterchain/{masterchain_seqno}/config/raw"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawBlockchainConfigFromBlock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawBlockchainConfigFromBlock",
			ID:   "getRawBlockchainConfigFromBlock",
		}
	)
	params, err := decodeGetRawBlockchainConfigFromBlockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *RawBlockchainConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawBlockchainConfigFromBlock",
			OperationSummary: "",
			OperationID:      "getRawBlockchainConfigFromBlock",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "masterchain_seqno",
					In:   "path",
				}: params.MasterchainSeqno,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawBlockchainConfigFromBlockParams
			Response = *RawBlockchainConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawBlockchainConfigFromBlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawBlockchainConfigFromBlock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawBlockchainConfigFromBlock(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawBlockchainConfigFromBlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawConfigRequest handles getRawConfig operation.
//
// Get raw config.
//
// GET /v2/liteserver/get_config_all/{block_id}
func (s *Server) handleGetRawConfigRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawConfig"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_config_all/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawConfig",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawConfig",
			ID:   "getRawConfig",
		}
	)
	params, err := decodeGetRawConfigParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawConfigOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawConfig",
			OperationSummary: "",
			OperationID:      "getRawConfig",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
				{
					Name: "mode",
					In:   "query",
				}: params.Mode,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawConfigParams
			Response = *GetRawConfigOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawConfigParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawConfig(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawConfig(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawConfigResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawListBlockTransactionsRequest handles getRawListBlockTransactions operation.
//
// Get raw list block transactions.
//
// GET /v2/liteserver/list_block_transactions/{block_id}
func (s *Server) handleGetRawListBlockTransactionsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawListBlockTransactions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/list_block_transactions/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawListBlockTransactions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawListBlockTransactions",
			ID:   "getRawListBlockTransactions",
		}
	)
	params, err := decodeGetRawListBlockTransactionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawListBlockTransactionsOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawListBlockTransactions",
			OperationSummary: "",
			OperationID:      "getRawListBlockTransactions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
				{
					Name: "mode",
					In:   "query",
				}: params.Mode,
				{
					Name: "count",
					In:   "query",
				}: params.Count,
				{
					Name: "account_id",
					In:   "query",
				}: params.AccountID,
				{
					Name: "lt",
					In:   "query",
				}: params.Lt,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawListBlockTransactionsParams
			Response = *GetRawListBlockTransactionsOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawListBlockTransactionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawListBlockTransactions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawListBlockTransactions(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawListBlockTransactionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawMasterchainInfoRequest handles getRawMasterchainInfo operation.
//
// Get raw masterchain info.
//
// GET /v2/liteserver/get_masterchain_info
func (s *Server) handleGetRawMasterchainInfoRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawMasterchainInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_masterchain_info"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawMasterchainInfo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *GetRawMasterchainInfoOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawMasterchainInfo",
			OperationSummary: "",
			OperationID:      "getRawMasterchainInfo",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetRawMasterchainInfoOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawMasterchainInfo(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawMasterchainInfo(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawMasterchainInfoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawMasterchainInfoExtRequest handles getRawMasterchainInfoExt operation.
//
// Get raw masterchain info ext.
//
// GET /v2/liteserver/get_masterchain_info_ext
func (s *Server) handleGetRawMasterchainInfoExtRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawMasterchainInfoExt"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_masterchain_info_ext"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawMasterchainInfoExt",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawMasterchainInfoExt",
			ID:   "getRawMasterchainInfoExt",
		}
	)
	params, err := decodeGetRawMasterchainInfoExtParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawMasterchainInfoExtOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawMasterchainInfoExt",
			OperationSummary: "",
			OperationID:      "getRawMasterchainInfoExt",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "mode",
					In:   "query",
				}: params.Mode,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawMasterchainInfoExtParams
			Response = *GetRawMasterchainInfoExtOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawMasterchainInfoExtParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawMasterchainInfoExt(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawMasterchainInfoExt(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawMasterchainInfoExtResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawShardBlockProofRequest handles getRawShardBlockProof operation.
//
// Get raw shard block proof.
//
// GET /v2/liteserver/get_shard_block_proof/{block_id}
func (s *Server) handleGetRawShardBlockProofRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawShardBlockProof"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_shard_block_proof/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawShardBlockProof",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawShardBlockProof",
			ID:   "getRawShardBlockProof",
		}
	)
	params, err := decodeGetRawShardBlockProofParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawShardBlockProofOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawShardBlockProof",
			OperationSummary: "",
			OperationID:      "getRawShardBlockProof",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawShardBlockProofParams
			Response = *GetRawShardBlockProofOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawShardBlockProofParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawShardBlockProof(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawShardBlockProof(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawShardBlockProofResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawShardInfoRequest handles getRawShardInfo operation.
//
// Get raw shard info.
//
// GET /v2/liteserver/get_shard_info/{block_id}
func (s *Server) handleGetRawShardInfoRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawShardInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_shard_info/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawShardInfo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawShardInfo",
			ID:   "getRawShardInfo",
		}
	)
	params, err := decodeGetRawShardInfoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawShardInfoOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawShardInfo",
			OperationSummary: "",
			OperationID:      "getRawShardInfo",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
				{
					Name: "workchain",
					In:   "query",
				}: params.Workchain,
				{
					Name: "shard",
					In:   "query",
				}: params.Shard,
				{
					Name: "exact",
					In:   "query",
				}: params.Exact,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawShardInfoParams
			Response = *GetRawShardInfoOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawShardInfoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawShardInfo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawShardInfo(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawShardInfoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawTimeRequest handles getRawTime operation.
//
// Get raw time.
//
// GET /v2/liteserver/get_time
func (s *Server) handleGetRawTimeRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawTime"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_time"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawTime",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *GetRawTimeOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawTime",
			OperationSummary: "",
			OperationID:      "getRawTime",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetRawTimeOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawTime(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawTime(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawTimeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRawTransactionsRequest handles getRawTransactions operation.
//
// Get raw transactions.
//
// GET /v2/liteserver/get_transactions/{account_id}
func (s *Server) handleGetRawTransactionsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRawTransactions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/liteserver/get_transactions/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRawTransactions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRawTransactions",
			ID:   "getRawTransactions",
		}
	)
	params, err := decodeGetRawTransactionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetRawTransactionsOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRawTransactions",
			OperationSummary: "",
			OperationID:      "getRawTransactions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "count",
					In:   "query",
				}: params.Count,
				{
					Name: "lt",
					In:   "query",
				}: params.Lt,
				{
					Name: "hash",
					In:   "query",
				}: params.Hash,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRawTransactionsParams
			Response = *GetRawTransactionsOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRawTransactionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRawTransactions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRawTransactions(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetRawTransactionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetReducedBlockchainBlocksRequest handles getReducedBlockchainBlocks operation.
//
// Get reduced blockchain blocks data.
//
// GET /v2/blockchain/reduced/blocks
func (s *Server) handleGetReducedBlockchainBlocksRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getReducedBlockchainBlocks"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/blockchain/reduced/blocks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetReducedBlockchainBlocks",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetReducedBlockchainBlocks",
			ID:   "getReducedBlockchainBlocks",
		}
	)
	params, err := decodeGetReducedBlockchainBlocksParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReducedBlocks
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetReducedBlockchainBlocks",
			OperationSummary: "",
			OperationID:      "getReducedBlockchainBlocks",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "from",
					In:   "query",
				}: params.From,
				{
					Name: "to",
					In:   "query",
				}: params.To,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetReducedBlockchainBlocksParams
			Response = *ReducedBlocks
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetReducedBlockchainBlocksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetReducedBlockchainBlocks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetReducedBlockchainBlocks(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetReducedBlockchainBlocksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStakingPoolHistoryRequest handles getStakingPoolHistory operation.
//
// Pool history.
//
// GET /v2/staking/pool/{account_id}/history
func (s *Server) handleGetStakingPoolHistoryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStakingPoolHistory"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/staking/pool/{account_id}/history"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStakingPoolHistory",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStakingPoolHistory",
			ID:   "getStakingPoolHistory",
		}
	)
	params, err := decodeGetStakingPoolHistoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetStakingPoolHistoryOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStakingPoolHistory",
			OperationSummary: "",
			OperationID:      "getStakingPoolHistory",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStakingPoolHistoryParams
			Response = *GetStakingPoolHistoryOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStakingPoolHistoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStakingPoolHistory(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStakingPoolHistory(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetStakingPoolHistoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStakingPoolInfoRequest handles getStakingPoolInfo operation.
//
// Stacking pool info.
//
// GET /v2/staking/pool/{account_id}
func (s *Server) handleGetStakingPoolInfoRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStakingPoolInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/staking/pool/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStakingPoolInfo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStakingPoolInfo",
			ID:   "getStakingPoolInfo",
		}
	)
	params, err := decodeGetStakingPoolInfoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetStakingPoolInfoOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStakingPoolInfo",
			OperationSummary: "",
			OperationID:      "getStakingPoolInfo",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStakingPoolInfoParams
			Response = *GetStakingPoolInfoOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStakingPoolInfoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStakingPoolInfo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStakingPoolInfo(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetStakingPoolInfoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStakingPoolsRequest handles getStakingPools operation.
//
// All pools available in network.
//
// GET /v2/staking/pools
func (s *Server) handleGetStakingPoolsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStakingPools"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/staking/pools"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStakingPools",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStakingPools",
			ID:   "getStakingPools",
		}
	)
	params, err := decodeGetStakingPoolsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetStakingPoolsOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStakingPools",
			OperationSummary: "",
			OperationID:      "getStakingPools",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "available_for",
					In:   "query",
				}: params.AvailableFor,
				{
					Name: "include_unverified",
					In:   "query",
				}: params.IncludeUnverified,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStakingPoolsParams
			Response = *GetStakingPoolsOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStakingPoolsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStakingPools(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStakingPools(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetStakingPoolsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStorageProvidersRequest handles getStorageProviders operation.
//
// Get TON storage providers deployed to the blockchain.
//
// GET /v2/storage/providers
func (s *Server) handleGetStorageProvidersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageProviders"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/storage/providers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageProviders",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *GetStorageProvidersOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStorageProviders",
			OperationSummary: "",
			OperationID:      "getStorageProviders",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetStorageProvidersOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStorageProviders(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStorageProviders(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetStorageProvidersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTonConnectPayloadRequest handles getTonConnectPayload operation.
//
// Get a payload for further token receipt.
//
// GET /v2/tonconnect/payload
func (s *Server) handleGetTonConnectPayloadRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTonConnectPayload"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/tonconnect/payload"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetTonConnectPayload",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *GetTonConnectPayloadOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTonConnectPayload",
			OperationSummary: "",
			OperationID:      "getTonConnectPayload",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetTonConnectPayloadOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTonConnectPayload(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTonConnectPayload(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetTonConnectPayloadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTraceRequest handles getTrace operation.
//
// Get the trace by trace ID or hash of any transaction in trace.
//
// GET /v2/traces/{trace_id}
func (s *Server) handleGetTraceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTrace"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/traces/{trace_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetTrace",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetTrace",
			ID:   "getTrace",
		}
	)
	params, err := decodeGetTraceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Trace
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTrace",
			OperationSummary: "",
			OperationID:      "getTrace",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "trace_id",
					In:   "path",
				}: params.TraceID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTraceParams
			Response = *Trace
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTraceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTrace(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTrace(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetTraceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWalletBackupRequest handles getWalletBackup operation.
//
// Get backup info.
//
// GET /v2/wallet/backup
func (s *Server) handleGetWalletBackupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWalletBackup"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/wallet/backup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetWalletBackup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWalletBackup",
			ID:   "getWalletBackup",
		}
	)
	params, err := decodeGetWalletBackupParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetWalletBackupOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWalletBackup",
			OperationSummary: "",
			OperationID:      "getWalletBackup",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "X-TonConnect-Auth",
					In:   "header",
				}: params.XTonConnectAuth,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWalletBackupParams
			Response = *GetWalletBackupOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWalletBackupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWalletBackup(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWalletBackup(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetWalletBackupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWalletsByPublicKeyRequest handles getWalletsByPublicKey operation.
//
// Get wallets by public key.
//
// GET /v2/pubkeys/{public_key}/wallets
func (s *Server) handleGetWalletsByPublicKeyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWalletsByPublicKey"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/pubkeys/{public_key}/wallets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetWalletsByPublicKey",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWalletsByPublicKey",
			ID:   "getWalletsByPublicKey",
		}
	)
	params, err := decodeGetWalletsByPublicKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Accounts
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWalletsByPublicKey",
			OperationSummary: "",
			OperationID:      "getWalletsByPublicKey",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "public_key",
					In:   "path",
				}: params.PublicKey,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWalletsByPublicKeyParams
			Response = *Accounts
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWalletsByPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWalletsByPublicKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWalletsByPublicKey(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeGetWalletsByPublicKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReindexAccountRequest handles reindexAccount operation.
//
// Update internal cache for a particular account.
//
// POST /v2/accounts/{account_id}/reindex
func (s *Server) handleReindexAccountRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reindexAccount"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/accounts/{account_id}/reindex"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReindexAccount",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReindexAccount",
			ID:   "reindexAccount",
		}
	)
	params, err := decodeReindexAccountParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReindexAccountOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReindexAccount",
			OperationSummary: "",
			OperationID:      "reindexAccount",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReindexAccountParams
			Response = *ReindexAccountOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReindexAccountParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReindexAccount(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReindexAccount(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeReindexAccountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSearchAccountsRequest handles searchAccounts operation.
//
// Search by account domain name.
//
// GET /v2/accounts/search
func (s *Server) handleSearchAccountsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("searchAccounts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/accounts/search"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchAccounts",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SearchAccounts",
			ID:   "searchAccounts",
		}
	)
	params, err := decodeSearchAccountsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *FoundAccounts
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SearchAccounts",
			OperationSummary: "",
			OperationID:      "searchAccounts",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "query",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchAccountsParams
			Response = *FoundAccounts
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchAccountsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchAccounts(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchAccounts(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeSearchAccountsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSendBlockchainMessageRequest handles sendBlockchainMessage operation.
//
// Send message to blockchain.
//
// POST /v2/blockchain/message
func (s *Server) handleSendBlockchainMessageRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendBlockchainMessage"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/blockchain/message"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SendBlockchainMessage",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SendBlockchainMessage",
			ID:   "sendBlockchainMessage",
		}
	)
	request, close, err := s.decodeSendBlockchainMessageRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *SendBlockchainMessageOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SendBlockchainMessage",
			OperationSummary: "",
			OperationID:      "sendBlockchainMessage",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *SendBlockchainMessageReq
			Params   = struct{}
			Response = *SendBlockchainMessageOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.SendBlockchainMessage(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.SendBlockchainMessage(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeSendBlockchainMessageResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSendRawMessageRequest handles sendRawMessage operation.
//
// Send raw message to blockchain.
//
// POST /v2/liteserver/send_message
func (s *Server) handleSendRawMessageRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendRawMessage"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/liteserver/send_message"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SendRawMessage",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SendRawMessage",
			ID:   "sendRawMessage",
		}
	)
	request, close, err := s.decodeSendRawMessageRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *SendRawMessageOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SendRawMessage",
			OperationSummary: "",
			OperationID:      "sendRawMessage",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *SendRawMessageReq
			Params   = struct{}
			Response = *SendRawMessageOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SendRawMessage(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SendRawMessage(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeSendRawMessageResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSetWalletBackupRequest handles setWalletBackup operation.
//
// Set backup info.
//
// PUT /v2/wallet/backup
func (s *Server) handleSetWalletBackupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setWalletBackup"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/v2/wallet/backup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SetWalletBackup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SetWalletBackup",
			ID:   "setWalletBackup",
		}
	)
	params, err := decodeSetWalletBackupParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeSetWalletBackupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *SetWalletBackupOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SetWalletBackup",
			OperationSummary: "",
			OperationID:      "setWalletBackup",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "X-TonConnect-Auth",
					In:   "header",
				}: params.XTonConnectAuth,
			},
			Raw: r,
		}

		type (
			Request  = SetWalletBackupReq
			Params   = SetWalletBackupParams
			Response = *SetWalletBackupOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSetWalletBackupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.SetWalletBackup(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.SetWalletBackup(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeSetWalletBackupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStatusRequest handles status operation.
//
// Status.
//
// GET /v2/status
func (s *Server) handleStatusRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("status"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v2/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "Status",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *ServiceStatus
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "Status",
			OperationSummary: "",
			OperationID:      "status",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *ServiceStatus
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.Status(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.Status(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTonConnectProofRequest handles tonConnectProof operation.
//
// Account verification and token issuance.
//
// POST /v2/wallet/auth/proof
func (s *Server) handleTonConnectProofRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tonConnectProof"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v2/wallet/auth/proof"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TonConnectProof",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TonConnectProof",
			ID:   "tonConnectProof",
		}
	)
	request, close, err := s.decodeTonConnectProofRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TonConnectProofOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "TonConnectProof",
			OperationSummary: "",
			OperationID:      "tonConnectProof",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *TonConnectProofReq
			Params   = struct{}
			Response = *TonConnectProofOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TonConnectProof(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.TonConnectProof(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			recordError("Internal", err)
		}
		return
	}

	if err := encodeTonConnectProofResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
